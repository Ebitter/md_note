> 2014-05-30

让领域模型发挥作用
=================
为了创建真正能为用户活动创造价值的软件，开发团队必须运用一整套与这些活动有关的知识体系，所需的知识广度可能令人望而生畏，信息量和复杂度也可能超乎想象。模型正是用于 __信息超载__ 的工具，它是一种知识形式，对知识进行 __有选择的 *简化*__ 和 __有目的的 *结构化*__ ，有助人们理解信息的意义，并 __专注于问题__ 相关的信息。

如书中提到，有关某镜头的取舍，剪辑人员站在专业角度（准确完成自己工作），但其核心作用（是否具有滑稽效果）被忽略了，这时理解领域核心的领导者能将软件项目带回正确的轨道。

随着对领域和应用程序需求的理解逐步加深，往往会丢掉那些最初看起来很重要的表面元素，或者 __切换它们的角度__。如对航运业务的认识从“集装箱在各地点之间的运输”转变为“运货责任在各个实体之间的传递”，处理这些责任的传递的特征不再是一些附属于装货作业和次要特征，而是一个独立的模型来支持。

抽象，分不同维度，开发人员为了支持设计的抽象，或领域专家对业务的抽象。面向对象技术可以使开发人员组织程序代码而受益，但真正的突破是描述模型中的概念

分离领域
=========
在一个运输应用程序中，要想支持从城市列表中选择运送货物目的地这样的简单用户行为，程序代码必须包括：

- 在屏幕上绘制一个屏幕组件（widget）
- 查询数据库，调出所有可能的城市
- 解析并验证用户输入
- 将所选城市与货物关联
- 向数据库提并此次数据修改

但只有 __一小部分__ 代码与运输 __业务相关__，如果领域有关的代码分散在大量其他代码之间，那么查看和分析领域代码就相当困难，给测试也带来困难。

想要创造能够处理复杂任务的程序，需要把不同的 __关注点分开__ 考虑，使设计中每个部分都得到单独关注，在分离的同时，也需要维持系统内部复杂的交互关系。普遍采用 __分层__：

- __用户界面层（表示层）__：负责向用户显示信息和解释用户指令。用户可以是另一个计算机系统，不一定是使用用户界面的的
- __应用层（门面服务）__：定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。应用层要尽量简单，不包含业务规则或知识，而只为下一层中的领域对象协调任务，分配工作。它没有反映业务情况的状态，但却可以为用户或程序显示某个任务的进度（工作流？）。
- __领域层（模型层）__：负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节由基础设施层实现，但反映业务情况的状态是由本层控制并使用的。领域层是业务软件的核心
- __基础设施层（工具+框架）__：为上层各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，还可通过架构框架来支持四层间的交互模式。

有些项目没有明显划分出用户界面层和应用层，而有些项目则有多个基础设施层，但将领域层分离出来才是实现 __Model-Driven Design__ 的关键

领域对象应该将重点放在如何表达领域模型上，而 __不需要__ 考虑自己的显示和存储问题，也 __无需管理__ 应用任务等内容。

软件中所表示的模型
=================
## 关联
一对多关联在实例变量中可以用一个集合来实现，但设计不一定要这样直接，可能没有集合，而使用一种访问方法（accessor method）来查询数据库，这两种设计反映同一个模型。

使关联更易于控制：

- 规定一个遍历方向
> 尽可能地对关系进行约束，双向关系只有将两个对象放在一起考虑才能理解它们，当应用不需要双向遍历时，可以指定一个遍历方向，以便减少相互依赖性，并简化设计

- 添加一个限定符，以便减少多重关联
> 尽管美国有很多位总统，但一个国家在一段时期内只能有一位总统，这个限定条件把多重关系简化为一对一关系

- 消除不必要的关联（非本质的关系）

## Entity(Reference Object)
很多对象不是通过它们的属性定义，而是通过一连串的连续事件和标识定义的。

一个人有一个标识，会陪伴他一生，这个人的物理属性会变，账务关系也会变，但标识却是永久的。

在对象的多个实现、存储形式和真实世界的参与者之间，概念性标识必须是匹配的，属性可以不匹配。

对象建模有可能把注意力引到对象的属性上，但 __实体概念是一种贯穿整个生命周期（甚至会经历多种形式）的抽象的连续性__。它们的类定义、职责、属性和关联必须围绕 __标识__ 来变化，而不会随着特殊属性来变化。可以跟踪它所经历的不同状态，甚至可以跨不同的实现跟踪它

### Entity建模
当对一个对象进行建模时，自然会考虑它的属性，而且考虑它的行为，但Entity最基本的  __职责是确保连续性__。保持实体的简练是实现这一责任的关键，只添加那些 __对概念至关重要的行为__ 和这些行为所必须的属性，此外，应该把行为和属性 __转移__ 到与核心实体关联的其他对象中，除了标识问题外，实体往往通过协调其它对象的操作来完成自己的职责。

## Value Object
很多对象没有概念上的标识，它们描述了一个事务的某种特征。只关心这些元素是什么，而不关心它们是谁。

画画时，关注的是画笔的颜色和笔尖的粗细，如果两只颜色和粗细相同的画笔，是不会介意使用哪一支。

Value Object可以是其他对象的集合，甚至可以引用Entity。它应该是 __不可变__ 的，不要为它分配任何标识。

经常作为参数在对象之间传递消息，常常是临时对象，在一次操作中被创建，然后丢弃。

### 设计Value Object
因为不关心使用的是哪个实例，不受这方面的约束，设计可以很自由，可以 __简化设计或优化设计：复制、共享或保持为不可变量__ （设计模式中Flyweight可应用于此，但无法用于Entity中）

共享VS复制，当以下情况时，优先使用共享：

- 当节省数据库空间或减少对象数据是一个关键要求时
- 当通信开销很低时
- 当共享的对象被严格限定为不可变时

但如果一个Value的实现是可变的，那么就不能共享它（只能复制），在可能的情况下，最好都设计为不可变的。

两个Value Object之间的双向关联完全没有意义。

## Service
有时，对象不是一个事物，在某些情况下，最清楚、最实用的设计会包含一些特殊的 __操作__（活动或动作），这些操作从概念上讲不属于任何对象，与其强制地归于某一类（Entity或者Value Object），还不如引入新的元素：Service。（尽管有可能违背了面向对象，贫血模型？）。当对软件必须实现某项 __无状态的活动__ 进行建模时，就可以将该活动作为一项Service

许多开发人员将"Manager"之类的名字结尾，看起来像模型对象，但除了一些操作之外没其它意义，也没有自己的状态，应该归于Service类别中

Entity和Value，它强调的与其他对象的关系，所谓Service定义了能够 __为客户做什么__，以一个活动命名，__动词__ 而不是名字，也应该有定义的职责

常见错误：

- 没有努力为这类行为找一个适当的对象，逐渐成为了 __过程化__ 的编程
- 勉强将一个操作放到不合适的对象中时，__模糊了原对象的角色与职责__
> 账户间转账功能属于一个领域层Service，因为它包含重要的业务规则（处理相应的借方账户和贷方账户），Service自己不会做太多事情，只要求两上Account对象完成大部分工作，但如果将“转账”操作强加Account对象上将很别扭。合理的做法是创建一个Funds Transfer对象来表示两个账户，外加一些与转账有关的规则和历史记录
- 代替了Entity的行为

好的Service特征：

- 与领域概念相关的操作不是Entity或Value的一个自然的部分
- 接口是根据领域模型的其他元素定义的
- 操作是无状态的（任何客户可以使用某个Service的任何实例，不必关心该实例的历史状态）

技术层（基础设施层）Service与领域层Service区别：

- 前者如发邮件，不包含业务意义；
- 后者则涉及业务逻辑，是在Entity和Value的基础上建立起来的，它们的行为类似于将领域的一些潜在功能组织起来以执行某种任务的脚本。而Entity和Value由于粒度过细而无法提供对领域层功能的便捷访问。
> 这里又要区别应用层Service与领域层Service，如银行应用程序可以把我们的交易进行转换并导出一个电子表格文件中，以便进行分析，这个导出应是一种应用层Service，“文件格式”在银行领域中是没以有意义的，也不涉及业务规则
- 将Service划分各层中示例
    - 资金转账应用服务：获取输入（如XML）；发送消息给领域层服务，要求其执行；__监听确认消息__；决定使用基础设施服务来发送通知
    - 资金转账领域服务：与必要的账户和总账对象进行交互，执行相应的借入和贷出操作；提供结果的确认（允许或拒绝转账等）
    - 基础设施层服务：按照应用程序的指示发送电子邮件、信件和其他信息。

## Module/Package
防止因框架、分层、打包等问题将领域对象的模型给拆散了，将持久化与UI分层是有必要的，但再拆分领域中对象到不同层是不可取的。

领域对象的生命周期
=================
## Aggregate
将关联减至最少的设计有助于简化对象之间的遍历，并在某种程度上限制关系的急剧增多。但大多数业务领域中的对象具有十分复杂的联系，以至于最终会形成一个很长、很深的对象引用路径，不得不在这个路径上追踪对象。这时候就需要该模式来指导建模

Aggregate就是一组相关对象的集合，作为数据修改的单元，每一个Aggregate都有一个根（root）和一个边界（boundary），边界定义了Aggregate的内部都有什么。根则是Aggregate中所包含的一个特定的Entity，在Aggregate中，根是唯一允许外部对象保持对它的引用的元素，而边界内部的对象之间则可以互相引用。除根外其他Entity都有本地标识，但只有在Aggregate内部才需要加以区别，因为外部对象除根Entity之外看不到其他对象。

固定规则（invariant）是指在数据变化时必须 __保持不变的一致性__ 规则，Aggregate内部的成员之间可能存在固定关系。Aggregate的所有规则 __并不是实时__ 都被更新为最新的状态，通过事件处理、批处理或其它更新机制，在一定时间内可以解决部分依赖性。但在每个事务完成时，必须要满足Aggregate内所有应用的固定规则的要求。

为了实现概念上的Aggregate，需要对所有事务应用一组规则：

- 根Entity具有全局标识，它最终负责检查固定规则
- 根Entity具有全局标识，边界内的E具有本地标识，这些标识只有在Aggregate内部才是唯一的
- Aggregate外部的对象不能引用除根Entity之外的任何内部对象，根Entity可以把对内部Entity的引用传递给它们，但这些对象只能临时使用这些引用，而不能保持引用（根可以把一个Value Object的 __副本__ 传递给另一个对象，而不必关心它发生什么变化，因为它只是一个Value，不再与Aggregate有任何关联）
- 只有Aggregate的根才能直接通过数据库查询获取，所有其他对象 __必须通过关联的遍历__ 才能找到
- Aggregate内部的对象可以保持对其他Aggregate根的引用
- 删除操作必须一次删除Aggregate边界之内的所有对象（GC很容易做到）
- 当提交对Aggregate边界内部的任何对象的修改时，整个Aggregate中所有 __固定规则__ 都必须被满足。

参考书中对PO的建模，通过减少对Part的依赖，保持了

## Factory
当创建一个对象或整个Aggregate时，如果创建工作很复杂，或者时暴露过多内部结构，可以使用Factory进行封装。

Factory有许多设计模式（Factory Method, Abstract Factory, Builder），任何好的工厂都需满足两上基本需求：

- 每个创建方法都是原子方法，而且满足被创建对象或Aggregate的所有固定规则，Factory应该以一致的状态来生成对象。在生成Entity时，意味着创建满足所有固定规则的整个Aggregate，但在创建完后可以向聚合添加一些可选元素。在创建不变的Value Object时，意味着所有属性必须被初始化为正确的最终状态。
- Factory应该被抽象为所需要的类型，而不是创建出具体的类。

### 选择Factory及其应用位置
一般情况下，Factory的作用是创建出的对象将细节隐藏起来，而且把Factory用在那些需要隐藏细节的地方，这些决定 __通常与Aggregate有关__

### 接口的设计
当设计Factory的方法签名时，必须遵守：

- 每个操作都必须是 __原子__ 的，我们必须在与Factory的一次交互中把创建对象 __所需的所有信息__ 传递给Factory，同时必须决定当某些固定规则没有被满足而导致创建失败时，将执行什么操作。
- 仔细考虑 __参数__，Factory将与其参数发生耦合，最安全的参数是来自较低层的设计层的参数，或选择与模型中密切相关的对象，而不增加新的依赖。使用 __抽象类型__ 的参数。

### 放置固定规则的逻辑
Factory负责确保它所创建的对象或Aggregate满足所有固定规则，但不代表应将规则称到该对象之外，Factory可以将 __固定规则检查工具delegate给产品__，而且这通常是最佳选择。Factory负责确保它所创建的对象或Aggregate满足所有固定规则，但不代表应将规则称到该对象之外，Factory可以将 __固定规则检查工具delegate给产品__，而且这通常是最佳选择。

### 重建已存储的对象
当从数据库中重建对象时，ORM技术就可以提供部分或全部所需服务；当从其他介质重建对象时，如果出现复杂情况，Factory是一个很好的选择。

## Repository
通过对象之间的 __关联__ 来找到对象，而不是基于数据库检索。当它处于生命周期的中间时，必须要有一个起点，以便从这个起点 __遍历__ 到一个Entity/Value。

数据库检索是全局可访问的，它使我们可以直接访问任何对象，但很可以滥用，是提供遍历还是领依靠检索，是一个设计决策，是检索的解耦与关联的内聚之间的权衡。
> Customer对象是否应该保持所有Order的集合？还是通过CustomerId在数据库中查找Order？
>
> 领域驱动设计的目标是通过关注领域模型，而不是技术来创建更好的软件，如果开发人员构造了一个SQL查询，并将它传递给基础设施层中某个查询服务，再根据得到的表行数据结果集提取所需信息，最后将这些信息传递给构造函数或工厂，当开发人员执行这一操作时，__早已不再把模型当重点__
>
> 更糟的是，由于直接使用数据库，开发人员会试图 __绕过模型的一些特色功能__（聚合、封装），直接操作他们所需的数据，导致越来越多的 __领域规则被嵌到查询__ 代码中。

Repository是一个简单的概念框架，将我们的注意力重新回到模型上，__它将同一类型的所有对象表示为一个概念集合（通常是模拟的），它行为类似于集合，只有具有更复杂的查询功能，在添加或删除相应类型的对象时，它的后台机制负责将对象添加到数据库中，或从数据库中删除对象__。

它的优点：

- 体现了对象访问的设计决策
- 为客户提供简单模型，可用来获取持久对象并管理它们的生命周期
- 使应用程序和领域设计与持久化技术解耦
- 很容易替换为"哑实现"（dummy implementation），以便测试

### Repository查询
基于Specification的查询特别适合作为一个框架来使用，客户可以 __使用规格（声明式）来描述__ 需要什么，而不关心如何获得结果。

但需要注意使用这些框架时，对性能的影响，考虑底层技术可能会限制我们的建模选择

### Repository与Factory
Factory负责处理对象生命周期的开始，而Repository帮助管理生命周期的中间和结束。由于Repository也是基于数据来创建对象，也许被误解为就是Factory，从技术角度而言是如此，但最好还是从模型角度来看待这一问题。

从领域驱动设计的角度，两者有不同的职责，Factory负责制造新对象，而Repository负责查找已有对象（还处在生命周期中间），它让客户感觉到那些对象好像驻留在内存中一样

这种职责上的区分还有助于Factory摆脱持久化职责，它的工作是用数据来实例化一个可能很复杂的对象，如果产品是一个新对象，那么客户将知道在创建完成之后应该把它添加到Repository中，由Repository的封装对象在数据库中的存储。




<!--
> DDD vs 四色建模
http://www.jdon.com/36343
http://www.jdon.com/tags/427
http://www.cnblogs.com/netfocus/archive/2011/01/17/1937779.html
http://www.cnblogs.com/netfocus/archive/2011/03/05/1971899.html
http://www.cnblogs.com/netfocus/archive/2011/07/10/2102099.html
http://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html
 -->




