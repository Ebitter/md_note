> 2015-05-28

Unix哲学基础
============
## Doug McIlroy
Doug McIlroy(Unix管道发明人)说过：

- 让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂
- 假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式输入。不要坚持使用交互式输入
- 尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是几星期内。对拙劣的代码别犹豫，扔掉重写
- 优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器

## Rob Pike
Rob Pike从另一个稍微不同的角度表达了Unix哲学：

- 你无法断定程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已证实那儿就是瓶颈所在
- 估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度
- 花哨的算法在n很小时通常很慢，而n通常很小。花哨算法的常数复杂度很大。除非你确定n总是很大，否则不要用花哨算法（即使n很大，也优先考虑上面原则）
- 花哨的算法比简单的算法更容易出bug，更难实现。尽量使用简单的算法配合简单的数据结构
- 数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法


## 模块原则
- __* 使用简洁的接口拼合简单的部件 *__

计算机编程的本质就是控制复杂度，而编制复杂软件而又不至于一败涂地的唯一的方法就是降低整体复杂度，用清晰的接口把若干简单的模块组合成一个复杂软件

## 清晰原则
- __* 清晰胜于机巧 *__

维护成本高昂，不仅仅要求代码注释，更意味着优雅而清晰的代码，它更容易让后来的修改者立即理解，而这个修改代码的人很可能是你自己

## 组合原则
- __* 设计时考虑拼接组合 *__

如果程序间不能有效通信，那么软件就难免陷入复杂。在输入输出方面，UNIX极力提倡采用 __简单、文本化、面向流、设备无关__ 的格式，多数程序都尽可能采用简单 __过滤器__ 的形式

在做一个GUI之前想想可不可以把复杂的交互程序跟算法程序分离开，每个部分单独成为一块，然后用简单的命令流或应用协议将其组合在一起

在构思精巧的数据传输格式前，考察一下，是否利用简单的文本数据格式，以一点点解析的代价，换得可以使用通用工具来构造或解读数据流的好处

## 分离原则
- __* 策略同机制分离，接口同引擎分离 *__

策略和机制是按照不同的 __时间尺度__ 变化的，策略变化要远远快于机制，两者剥离，就可能在探索新策略时不足以打破机制，也容易为机制写出较好的 __测试__

将应用按照一个库来编写，这个库包含许多C __服务__ 程序，而整个应用的 __控制流__ 则用脚本来写（如Emacs）

另一种方法是将应用程序分成可以协作的 __前端进程__ 和 __后端进程__ ，通过 __套接字__ 上层的专用应用协议进行通讯，前端实现策略，后端实现机制

## 简洁原则
- __* 设计要简洁，复杂度能低则低 *__

程序员喜欢以玩转复杂东西和耍弄抽象概念的能力为傲，但如果设计能力，超出实现和排错能力，结果便是代价高昂的废品

## 吝啬原则
- __* 除非确无它法，不要编写庞大的程序 *__

大有两重含义：体积大，复杂程度高。维护起来就困难

## 透明性原则
- __* 设计要可见，以便审查和调试 *__

调试通常会占用四分之三甚至更多的开发时间，一开始多做点工作以减少日后调试的工作量会很划算

透明性指一眼就能看出软件是在做什么以及怎样做的；显见性指程序带有 __监视和显示内部状态__ 的功能

调试选项应该在设计之初就考虑进去

## 健壮原则
- __* 健壮源于透明与简洁 *__

在有异常输入的情况下，保证软件健壮性的一个方法就是避免在代码中出现特例。软件透明性指一眼能看出怎么回事，不需要绞尽脑汁去推断所有可能情况，这个程序就是简洁的，也就越健壮

## 表示原则
- __* 把知识叠入数据以求逻辑质朴而健壮 *__

即使简单的 __逻辑__ 让人类来验证也很 __困难__ ，但就算是复杂的 __数据__ ，对人类来说还是相对 __容易__ 的能够推导和建模

数据要比编程逻辑更容易驾驭，应主动将代码的复杂度移到数据之中去

## 通俗原则
- __* 接口设计避免标新立异 *__，也就是 __最少惊奇原则__

在设计接口时，尽量按照用户最可能熟悉的同样功能接口和相似应用程序来进行建模

Unix世界形成了一套系统的惯例，如配置和运行控制文件的格式，命令行开关等

## 缄默原则
- __* 如果一个程序没什么好说的，就沉默 *__

即不要输出程序内部行为信息，只显示重要的信息，方便作为另一处程序的输入

## 补救原则
- __* 出现异常时，马上退出并给出足够错误信息 *__

软件尽可能从容应付各种错误输入和自身的运行错误，但如果做不到这一点，就让程序尽可能以一种容易诊断错误的方式终止

Postel规范 __“宽容地收，谨慎地发”__，当输入的数据很不规范，一个设计良好的程序也会尽量领会其中意义，以尽量与别的程序协作，然后，要么响亮的倒踏，要么为工作链下一环的程序输出一个严谨干净正确的数据

MCIlroy要求在设计时要考虑宽容性，而不是用过分纵容的实现为补救标准的不足，比如Html的兼容性

## 经济原则
- __* 宁花机器一分，不花程序员一秒 *__

大多数应用场合都应该使用高一级的语言（perl,python,java,lisp）

## 生成原则
- __* 避免手工hack，尽量编写程序去生成程序 *__

程序中任何手工hacking都是滋生错误和延误的温床

当代码生成器能够提升抽象度时，即当生成器的说明性语句要比生成代码简单时，使用代码生成器会很合算，而生成代码后就根本无需再费力地去手工处理了

Parser/Lexer生成器就是经典例子，Makefile生成器将构建工作自动化

## 优化原则
- __* 雕琢前先要有原型，跑之前先学会走 *__

过早优化是万恶之源，还不知道瓶颈所在就勿忙进行优化，是一个比乱加功能更损害设计的错误。而且过早局部优化实际会妨碍全局优化

优化之前先确保能用

## 多样原则
- __* 决不相信所谓“不二法门”的断言 *__

Unix奉行的是广泛采用多语言、开放的可扩展系统和用户定制机制

## 扩展原则
- __* 设计着眼未来，未来总比预想来得快 *__

设计协议或文件格式时，应使其具有充分的自描述性以便可以扩展。要么包含一个版本号，要么采用独立、自描述的语句，按照可以随时插入新的、换掉旧的而不会搞乱格式读取代码的方法组织格式。稍微增加一点让数据部署具有自描述性的开销，就可以在无需破坏整体的情况下进行扩展

## 应用Uiux哲学
- 只要可行，一切都应该做成与来源和目标无关的过滤器
- 数据流尽可能文本化(这样可以使用标准工具来查看和过滤)
- 数据库部署和应用协议应尽可能文本化(让人可以阅读和编辑)
- 复杂的前端(用户界面)和后端应该泾渭分明
- 如果可能，用C编写前，先用解释性语言搭建原型
- 当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好
- 宽收严发(对接收的东西要包容，对输出的东西要严格)
- 过滤时，不需要丢弃的信息决不丢
- 小就是美，在确保完成任务的基础上，程序功能尽可能少





