> 2015-05-28

Unix哲学基础
============
## Doug McIlroy
Doug McIlroy(Unix管道发明人)说过：

- 让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂
- 假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式输入。不要坚持使用交互式输入
- 尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是几星期内。对拙劣的代码别犹豫，扔掉重写
- 优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器

## Rob Pike
Rob Pike从另一个稍微不同的角度表达了Unix哲学：

- 你无法断定程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已证实那儿就是瓶颈所在
- 估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度
- 花哨的算法在n很小时通常很慢，而n通常很小。花哨算法的常数复杂度很大。除非你确定n总是很大，否则不要用花哨算法（即使n很大，也优先考虑上面原则）
- 花哨的算法比简单的算法更容易出bug，更难实现。尽量使用简单的算法配合简单的数据结构
- 数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法


## 模块原则
- __* 使用简洁的接口拼合简单的部件 *__

计算机编程的本质就是控制复杂度，而编制复杂软件而又不至于一败涂地的唯一的方法就是降低整体复杂度，用清晰的接口把若干简单的模块组合成一个复杂软件

## 清晰原则
- __* 清晰胜于机巧 *__

维护成本高昂，不仅仅要求代码注释，更意味着优雅而清晰的代码，它更容易让后来的修改者立即理解，而这个修改代码的人很可能是你自己

## 组合原则
- __* 设计时考虑拼接组合 *__

如果程序间不能有效通信，那么软件就难免陷入复杂。在输入输出方面，UNIX极力提倡采用 __简单、文本化、面向流、设备无关__ 的格式，多数程序都尽可能采用简单 __过滤器__ 的形式

在做一个GUI之前想想可不可以把复杂的交互程序跟算法程序分离开，每个部分单独成为一块，然后用简单的命令流或应用协议将其组合在一起

在构思精巧的数据传输格式前，考察一下，是否利用简单的文本数据格式，以一点点解析的代价，换得可以使用通用工具来构造或解读数据流的好处

## 分离原则
- __* 策略同机制分离，接口同引擎分离 *__

策略和机制是按照不同的 __时间尺度__ 变化的，策略变化要远远快于机制，两者剥离，就可能在探索新策略时不足以打破机制，也容易为机制写出较好的 __测试__

将应用按照一个库来编写，这个库包含许多C __服务__ 程序，而整个应用的 __控制流__ 则用脚本来写（如Emacs）

另一种方法是将应用程序分成可以协作的 __前端进程__ 和 __后端进程__ ，通过 __套接字__ 上层的专用应用协议进行通讯，前端实现策略，后端实现机制

## 简洁原则
- __* 设计要简洁，复杂度能低则低 *__

程序员喜欢以玩转复杂东西和耍弄抽象概念的能力为傲，但如果设计能力，超出实现和排错能力，结果便是代价高昂的废品

## 吝啬原则
- __* 除非确无它法，不要编写庞大的程序 *__

大有两重含义：体积大，复杂程度高。维护起来就困难

## 透明性原则
- __* 设计要可见，以便审查和调试 *__

调试通常会占用四分之三甚至更多的开发时间，一开始多做点工作以减少日后调试的工作量会很划算

透明性指一眼就能看出软件是在做什么以及怎样做的；显见性指程序带有 __监视和显示内部状态__ 的功能

调试选项应该在设计之初就考虑进去

## 健壮原则
- __* 健壮源于透明与简洁 *__

在有异常输入的情况下，保证软件健壮性的一个方法就是避免在代码中出现特例。软件透明性指一眼能看出怎么回事，不需要绞尽脑汁去推断所有可能情况，这个程序就是简洁的，也就越健壮

## 表示原则
- __* 把知识叠入数据以求逻辑质朴而健壮 *__

即使简单的 __逻辑__ 让人类来验证也很 __困难__ ，但就算是复杂的 __数据__ ，对人类来说还是相对 __容易__ 的能够推导和建模

数据要比编程逻辑更容易驾驭，应主动将代码的复杂度移到数据之中去

## 通俗原则
- __* 接口设计避免标新立异 *__，也就是 __最少惊奇原则__

在设计接口时，尽量按照用户最可能熟悉的同样功能接口和相似应用程序来进行建模

Unix世界形成了一套系统的惯例，如配置和运行控制文件的格式，命令行开关等

## 缄默原则
- __* 如果一个程序没什么好说的，就沉默 *__

即不要输出程序内部行为信息，只显示重要的信息，方便作为另一处程序的输入

## 补救原则
- __* 出现异常时，马上退出并给出足够错误信息 *__

软件尽可能从容应付各种错误输入和自身的运行错误，但如果做不到这一点，就让程序尽可能以一种容易诊断错误的方式终止

Postel规范 __“宽容地收，谨慎地发”__，当输入的数据很不规范，一个设计良好的程序也会尽量领会其中意义，以尽量与别的程序协作，然后，要么响亮的倒踏，要么为工作链下一环的程序输出一个严谨干净正确的数据

MCIlroy要求在设计时要考虑宽容性，而不是用过分纵容的实现为补救标准的不足，比如Html的兼容性

## 经济原则
- __* 宁花机器一分，不花程序员一秒 *__

大多数应用场合都应该使用高一级的语言（perl,python,java,lisp）

## 生成原则
- __* 避免手工hack，尽量编写程序去生成程序 *__

程序中任何手工hacking都是滋生错误和延误的温床

当代码生成器能够提升抽象度时，即当生成器的说明性语句要比生成代码简单时，使用代码生成器会很合算，而生成代码后就根本无需再费力地去手工处理了

Parser/Lexer生成器就是经典例子，Makefile生成器将构建工作自动化

## 优化原则
- __* 雕琢前先要有原型，跑之前先学会走 *__

过早优化是万恶之源，还不知道瓶颈所在就勿忙进行优化，是一个比乱加功能更损害设计的错误。而且过早局部优化实际会妨碍全局优化

优化之前先确保能用

## 多样原则
- __* 决不相信所谓“不二法门”的断言 *__

Unix奉行的是广泛采用多语言、开放的可扩展系统和用户定制机制

## 扩展原则
- __* 设计着眼未来，未来总比预想来得快 *__

设计协议或文件格式时，应使其具有充分的自描述性以便可以扩展。要么包含一个版本号，要么采用独立、自描述的语句，按照可以随时插入新的、换掉旧的而不会搞乱格式读取代码的方法组织格式。稍微增加一点让数据部署具有自描述性的开销，就可以在无需破坏整体的情况下进行扩展

## 应用Uiux哲学
- 只要可行，一切都应该做成与来源和目标无关的过滤器
- 数据流尽可能文本化(这样可以使用标准工具来查看和过滤)
- 数据库部署和应用协议应尽可能文本化(让人可以阅读和编辑)
- 复杂的前端(用户界面)和后端应该泾渭分明
- 如果可能，用C编写前，先用解释性语言搭建原型
- 当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好
- 宽收严发(对接收的东西要包容，对输出的东西要严格)
- 过滤时，不需要丢弃的信息决不丢
- 小就是美，在确保完成任务的基础上，程序功能尽可能少

对比Unix哲学
============
## 协作进程
在Unix中，低价的进程生成和简便的进程间通讯(IPC)使众多小工具、管道和过滤器组成一个均衡系统成为可能

> 进程是自主运算单元的统一性记号、而进程控制是可编程的，shell只是另一个进程

如果操作系统的进程生成代价昂贵，或进程控制非常困难、不灵活，后果通常是：

- 编写怪物巨大的单个程序成为更自然的编程方式
- 很多策略必须在这些庞大程序中表述，助长使用C++式内部代码层级，而不是C相对平坦的内部层级
- 当进程间不得不进行通讯时，只能采用笨拙、低效、不安全的机制（比如临时文件），要么就得依赖太多彼此的实现细节，要么彼此需了解对方的太多实现细节
- 广泛使用多线程来完成某些任务，而这些任务Unix只需要互通的多进程就能处理

## 内部边界
Unix的准绳是：程序员最清楚一切，当你对自己数据进程危险操作时，并不阻止你，也不会要确认，但Unix却小心避免踩在别人的数据。

系统程序通常都有自己的伪用户（pseudo-user），以访问专门的系统文件，而不需要无限的（比如超级用户）访问权限

Unix至少设立三层内部边界来防范恶意用户或有缺陷的程序：

- 内存管理，使用硬件MMU来保证各自进程不会侵入到其它进程的内存地址空间
- 为多用户设置的真正权限组，普通用户的进程未经允许，就不能更改或读取其他用户文件
- 把涉及关键安全性的功能限制在尽可能小的可信代码块上

> 在Unix中，shell也不是特权程序

## 二进制文件格式
如果操作系统使用二进制文件格式存放关键数据（如用户账号记录），应用程序采用可读文本格式的传统很可能无法形成

- 即使支持命令行接口、脚本和管道，也几乎无法形成过滤器
- 数据文件只有通过专用工具才能访问，开发者的思维会以工具而非数据为中心，这样不同版本的文件格式很难兼容

## 命令行界面
如果操作系统的命令行界面CLI功能很弱或根本不存在，其后果是：

- 程序设计不会考虑以未预料的方式相互协作--因为无法这样设计，输出不能用作输入
- 远程系统管理更难于实现，更难以使用，更强调网络
- 即便简单的非交互程序也将招致GUI开销或复杂的脚本接口
- 服务器、守护程序和后台进程几乎无法写出，至少很难以优雅的方式写出

模块性：保持清晰，保持简洁
========================
Unix程序员骨子里的传统是：更加笃信重视模块化、更注重正交性和紧凑性等问题

## 封装的最佳模块大小
模块化代码的首要特质就是 __封装__，不会过多向外部披露自身的细节，不会直接调用其它模块的实现码，也不会胡乱共享全局数据。模块间通过应用程序接口API－－一组严密、定义良好的程序调用和数据结构来通信

API在模块间扮演双重角色，在 __实现层__ 面，作为模块间的滞塞点（choke point），阻止各自的内部细节被相邻模块知晓；在 __设计层__ 面，正是API真正定义了整个体系

## 紧凑性和正交性
### 紧凑性
紧凑性就是一个设计是否能装进人脑中的特性，有经验的用户通常不需要操作手册时，这个设计就是紧凑的

但紧凑不代表容易学习，需要掌握内在的基础概念模型后，整个视角都会改变，比如Lisp

评测一个API紧凑性经验法则，编程者需要记忆的条目大于七吗，unix系统调用API是半紧凑的，C标准库则不是紧凑的，C++是反紧凑的

合理对待紧凑性，设计中尽量考虑，但不是一个绝对要求

### 正交性
在纯粹的正交设计中，任何操作均 __无副作用__；每一个动作（API调用、宏调用、语言运算）只改变一件事，不会影响其它。无论控制什么系统，改变每个属性的方法 __有且只有一个__

显示器就是正交控制的，可以独立改变亮度而不影响对比度，而色彩平衡控制也独立于前两个属性

比如从某一源到另一目标进行数据读取和解析时，不要认为源格式总是存储在某个磁盘文件中，输入完成可以来自标准输入、网络套接字或其它数据流，转换函数是正交设计时，应只考虑一个打开的文件描述符

如果副作用扰乱了程序员或用户的思维模式，就出现了非正交性问题，总需要被迫做额外的工作来修正它们

正交性缩短了测试和开发时间，需要 __测试的情况组合要少得多__，如果正交性代码出现问题，把它替换掉而不影响系统其余部分也很容易做到，正交性的代码更容易文档化和复用

整体而言，Unix API是正交性设计比较好的例子

> 其实重构的原则性目的，就是提高正交性

### SPOT原则
正交性的的一条原则：不要重复自身，任何一个知识点在系统内部都应当有一个唯一、明确、权威的表述。这个原则称为 __真理的单点性（SPOT: single point of truth）__

重复会导致前后矛盾、产生隐微问题的代码，当修改重复点时，往往只改变了一部分而并非全部，也意味着对代码的组织没有想清楚

- 常量、表和元数据只应该声明和初始化一次，并导入其它地方
- 如果代码中含有重复数据是因为在两个不同的地方必须使用两个不同的表现形式，能否写个函数、工具或代码生成程序，让其中一个由另一个生成，或两者都来自同一个来源？
- 如果文档重复了代码中的知识点，能否从部分代码中生成部分文档，或者反之，或者两者都来自同一个更高级的表现形式？
- 如果头文件和接口声明重复了实现代码中的知识点，是否可以找一种方法，从代码中生成头文件和接口声明？

数据结构也存在SPOT原则，无垃圾、无混淆，数据结构应该最小化，不要让数据结构太通用，在真实世界中绝对明确清晰的状态在模型中也一样明确清晰

- 是不是因为缓存了其个计算或查找的中间结果而复制了数据？是不是一种过早优化；陈旧的缓存（以及保持缓存同步所必需的代码层）是滋生bug的温床
- 如果有大量重复的样板代码，是不是可以用单一的更高层表现形式生成这些代码、然后通过提供不同细调选项生成不同个例？

### 紧凑性和强单一中心
要提高设计的紧凑性，围绕"解决一个定义明确的问题"的强核心算法组织设计，避免臆断和捏造

Uinx中许多非常有效的工具都是围绕某个单一强大算法直接转换的一个瘦包装器

- 比如`diff`采用了数学模型和可靠的算法，没有特殊情况，没有令人痛苦的边界条件，结果清晰一致，不会出现试探可能带来的意外
- 通过模式匹配从中挑选文本行的`grep`，如果没有数学模型，可能像古老的`glob`设计，只是一堆无法组合在一起的专门通配符
- 用于生成语法解析器的`yacc`是围绕LR语法形式理论的瘦包装器，词法分析生成器`lex`则是围绕不确定有限态自动机的瘦包装器

与 __形式法__ 相对的是 __试探法__，凭经验法则得出的解决方案，概率上可能正确，但不一定总是正确，如垃圾邮件过滤，就需要群智编程，虚拟内存管理也是这样

试探法的问题在于会增生出大量特例和边界情况

## 软件是多层的
### 自顶向下和自底向上
自顶向上，从具体到抽象，从问题域中确定要进行的具体操作开始，向上进行；另一个是自顶向下，从抽象到具体，从最高层面描述整个项目的规格说明或应用逻辑开始，向下进行，直到各个具体操作

二者的差异，就是设计是围绕主事件循环（常常具备与其非常接近的高级应用逻辑）组织，还是围绕主循环可能调用的所有操作的服务库组织代码

自顶向下的设计通常先考虑程序的主事件循环，以后才插入具体的事件。自底向上的设计者通常考虑封装具体的任务，以后再按某种相关次序把这些东西粘合在一起

网页浏览器的顶层设计是对浏览器预期行为的规格说明：可以解析什么类型的URL，可以渲染哪些类型的图像，是否可以或带限制的支持java或javascript。与这个顶层意图相对应的实现层是浏览器的主事件循环；在每个周期内，这处循环等待、收集、分派用户的动作

如果完全自顶向下设计，可能陷入非常不舒服的境地，应用逻辑所需的域原语与真正能实现的域原语无法匹配。但完全自底向上设计，很可能发现自己做了许多与应用逻辑无关的工作

更好的方式是，一方面自顶向下的应用逻辑表达抽象规范，另一方面以函数或库来收集底层的域原语，当高层的设计变化时（GUI根本不存在所谓正确行为），这些域原语仍然可以重用

同一项目经常同时兼有自顶向下的代码和自底向上的代码，导致了 __胶合层__ 的出现

### 胶合层
顶层的应用逻辑和底层的域原语集必须用胶合逻辑层来进行 __阻抗匹配(impedance match)__

胶合层是个挺讨厌的东西，必须尽可能 __薄__，它用来将东西粘一起，但不应该用来隐藏各层的裂痕和不平整。

如果设计者意识到胶合层的存的，并试图围绕自身的一套数据结构或对象把胶合层组织成一个中间层，结果却 __导致了两个胶合层__ －－一个在中间层之上，一个在中间层之下，每个基本集（应用逻辑、中间层、域原语）都做得很好，但因为整合这些漂亮的代码所需的胶合层越来越 __厚__ ，最终苦苦挣扎

薄胶合层可看作是分离原则的升华，策略（应用逻辑）应与机制（域原语）清晰的分离，如果有许多代码即不属于策略又不属于机制，可能就有问题

## 程序库
强调模块性和定义良好的API，所产生的影响就是：强烈倾向于把程序分解成由胶合层连接的库集合，特别是共享库。

常常可以把程序划分为：一个是用户界面处理的主要部分（策略），另一个是服务例程的集合（机制），前端专门解决用户界面和高层协议的问题，甚至可以将原始的前端分离出来，用适于不同用途的其它部件代替。

作为程序库发布，必须携带练习程序，作为 __测试框架__

库分层的一个重要形式是 __插件__，即拥有一套已知入口、可在启动以后动态从入口处载入来执行特定任务的库，这种模式必须将调用程序作为文档详备的服务库组织起来，以使得插件可以回调

## Unix和面向对象语言
面向对象编程中，作用于具体数据结构的函数和数据一起被封装在可视为单元的一个对象中，非OO语言中的模块使数据和作用于该数据的函数的联系变得相当无规律，而且模块间还经常互相泄漏数据或内部细节

C语言模仿真正的对象很费力，堆砌抽象层是一件非常累人的事，所以C中对象层倾向比较平坦和透明，OO语言使抽象层变得很容易，具有厚重的胶合和复杂层次，使程序员陷入过度分层的倾向，过多的层次破坏了透明性，无法看清层次，也无法在头脑中理清代码到底是怎样运行的

## 模块式编码
- 有多少全局变量？它对模块化是毒药，很容易使各模块轻率、混乱地互相泄漏信息
- 单个模块的大小是否在Hatton的最佳范围内（即最佳物理行数建议应在400至800行之间）
- 模块内的单个函数是不是太大了？也许不是行数的问题，而是一个内部复杂度的问题，如果不能简单描述一个函数与其调用程序之间的约定，这个函数可能太大了
- 如果局部变量太多，代码行有太多缩进，也倾向拆分子程序
- 代码是不是有内部API，即可作为单元向其他人描述的函数调用集和数据结构集，并且每一个单元都封装了某一层次的函数，不受其它代码的影响
- API的入口点是否超过七个？有没有哪个类有七个以上方法？数据结构的成员是不是超过七个？
- 整个项目中每个模块的入口点数量如何分布（`ctags`生成标记文件）？是不是不均匀？有很多入口点的模块真的需要这么多入口点吗
