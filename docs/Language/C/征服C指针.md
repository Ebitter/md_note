> 2014-08-01

C是什么样的语言
===============

## 只能使用标量
__标量__ 就是指`char`、`int`、`double`和`枚举`等数值类型，以及`指针`，相对的，像`数组`、`结构体`和`共用体`这样的将多个标量进行组合的类型，称为 __聚合类型__(aggregate)

`if(str == "abc")`这样的代码为什么不能执行预期的动作呢，确实已经将"abc"放到了`str`中，条件表达式却不为真。

- 通常答案是，这个表达式不是在比较字符串的内容，它只是 __在比较指针__
- 另一个答案是，字符串其实就是char类型的数组，也就是说它 __不是标量__，当然在C里面不能用`==`进行比较了。

C语言是一门，不用说对输入输出，就连数组和结构体也放弃了通过语言自身进行整合利用的语言。

但如今ANSI C通过以下几个追加的功能（早期C语言不存在），能够让我们整合地使用聚合类型了：

- 结构体的一次赋值（无须再使用`memcpy()`）
- 将结构体作为函数返回值传递
- 将结构体作为函数返回值返回
- auto变量的初始化

但依然不能做到对数组的整合利用，如数组赋值给另外一个数组，或者将数组作为参数传递。所以在结构体能替换数组的情况下，应优先使用。

## 关于指针
指针类型、指针类型变量、指针类型的值，经常被简单的统称为“指针”，造成歧义，必须明确：

- 先有 __指针类型__
- 所以有了 __指针类型的 *变量*__ 和 __指针类型的 *值*__(内存的地址)

### 变量保存状况

<!--language: !c-->

    #include <stdio.h>
    int main(void){
        int hoge = 5;
        int piyo = 10;
        int *hoge_p;

        printf("&hoge..%p\n", &hoge);
        printf("&piyo..%p\n", &piyo);
        printf("&hoge_p..%p\n", &hoge_p);

        hoge_p = &hoge;
        printf("hoge_p..%p\n", hoge_p);

        return 0;
    }

发现变量按照声明的逆向顺序保存在内存中，这是常见的现象，但非一定，即变量 __不一定__按照声明顺序保存的内存中（但结构体中成员变量在内存中布局与声明顺序一致）。

<!--language: plain-->

               ┌──────────┐
               │    5     │  hoge
    0x76cd5a78 ├──────────┤
               │    10    │  piyo
    0x76cd5a74 ├──────────┤
               │0x76cd5a78│  hoge_p
    0x76cd5a70 └──────────┘

### 指针和地址之间关系
几乎所有的处理程序中，所谓的“指针类型的值”，实际上是指内存的地址。对此的疑问有：

- 归根结底，指针就是地址，地址就是内存中被分配的“门牌号”，所以，指针类型和int类型是一回事吧
    - 在C中，指针和整数是没有区别的，但运行环境不具有普适性，很多运行环境中，int类型和指针类型的长度并不相同，此外，对于分段寻址的（段地址+偏移量）也不适用。

- 指针就是地址吧，那么指向int的指针也好，指向double的指针也好，它们有什么不一样吗，有必要区分它们吗？
    - 对于大部分运行环境来说，当程序运行时，不管是指向int的指针，还是指向double的指针，都保持相同的表现形式（偶尔在一些运行环境中，指向char指针和指向int的指针有不一样的内部表示和位数）

<!--language: !c-->

    #include <stdio.h>
    int main(void){
        int hoge = 5;
        void *hoge_p;

        hoge_p = &hoge;
        /* printf("%d\n", *hoge_p);*/
        /* warning: dereferencing 'void *' pointer invalid use of void expression*/
        printf("%d\n", *(int*)hoge_p);

        return 0;
    }

<!--language: !c-->

    #include <stdio.h>
    int main(void){
        int *int_p;
        double double_variable = 5;

        int_p = &double_variable;
        /* warning: assignment from incompatible pointer type*/

        return 0;
    }

### 指针运算
指针运算是针对指针进行 __整数加减__ 运算，以及 __指针之间进行减法__ 运算的功能。

对指针加N，指针前进“当前指针指向的数据类型的长度*N”。由此也可见“编译器记住指针指向什么样的类型”是有重要意义的

指针加减运算，标准只允许指针指向数组内的元素，或者超过数组长度的下一个元素，标准没有对除此之外的情况做出任何定义。

下例有点违反C语言标准，但在大多数环境下，是可行的

<!--language: !c-->

    #include <stdio.h>
    int main(void){
        int hoge1 = 5;
        int hoge2 = 10;
        int *hoge_p;

        hoge_p = &hoge1;
        printf("hoge_p..%p\n", hoge_p);

        hoge_p++;
        printf("hoge_p..%p\n", hoge_p);
        printf("*hoge_p..%d\n", *hoge_p);

        return 0;
    }

如果指针类型的长度与整形的长度一致的话，最后一行将输出`10`

### 什么是空指针
空指针是指可以确保没有指向任何一个对象的指针，通常使用宏定义`NULL`来表示空指针常量值

如今的操作系统下，应用程序一旦试图通过空指针引用对象，就会马上招致一个异常并且当前应用程序会被操作系统强制终止。因此，如果每次都使用`NULL`来初始化指针变量，在错误的使用了无效（未初始化）的指针时，我们就会马上发现潜在BUG

`NULL`无论对方指向什么类型的变量，都可被赋值和比较，偶尔会见到先将空指针强制转型，然后再赋值、比较的程序，不但是徒劳的，还不易于阅读。

### 函数参数
调用C的函数，参数传递往往是 __传值__，这种方式传递的是参数的 __副本__（形参是实参的副本）。

函数的 __形参__ 都和调用时被设定值的 __局部变量__ 一样，如果不这样的话，就会背负Fortran那样的危险，或者像Pascal那样在语法下的做些文章。

#### 修改参数好吗
C的形参可以和事先被设定的值的局部变量同样使用，对值进行修改在语法上没有任何问题，但却不推荐，因为参数是从调用方得到的非常重要的信息，如果修改了参数，就再也恢复不了，不利于调试。

## 关于数组
数组的内存布局大概如下：

<!--language: plain-->

               ┌──────────┐
               │          │  array[2]
    0xbfd24390 ├──────────┤
               │          │  array[1]
    0xbfd2438c ├──────────┤
               │          │  array[0]
    0xbfd24388 └──────────┘

### 数组和指针
给指针加N，指针前进“当前指针指向的变量类型的长度*N”，因此，给指向数组的某个元素的指针加N后，指针会指向N个之后的元素

<!--language: !c-->

    #include <stdio.h>
    int main(int argc, const char* argv[]){
        int array[] = {1,2,3,4,5};
        int *p;
        for(p=&array[0]; p!=&array[5]; p++){
            printf("%d\n", *p);
        }

        return 0;
    }

通过`p++`顺序地移动指针，引导指针指向`&array[5]`(尽管它不存在)，使用`++`运算符给指针加1，指针前进`sizeof(int)`个字节

但无论写成`p++`或`*(p+i)`都不容易阅读，还是`a[i]`的方式更容易理解，也是本书推荐的方式，实际上`a[i]`正是`*(p+i)`的 __语法糖__

### 下标运算符`[]`和数组没有关系
- __表达式中__，数组可以解读成"指向它的初始元素的指针"（有三个小例外，但这和后面要不要加`[]`没有关系）
- `p[i]`是`*(p+i)`的简便写法，下标运算符`[]`只有这种用法，它和数组无关
- `p[i]`可以写成`i[p]`
- 声明中的`[]`还是表达数组的意思，但表达式中完全不同，就像`*`在声明中（指针变量）与表达式中（解引用）完全不同一样。

#### 序列化
在网络通讯中，数据交换程序中经常使用一个char数组保存各种数据类型的数据，称为序列化，在一个巨大的char数组中，参杂了各种类型的数据，当我们试图读取多少字节的数据时，使用指针运算写法，会比下标运算符更容易理解

### 数组作为函数的参数传递
<!--language: !c-->

    #include <stdio.h>
    #include <stdlib.h>
    #include <ctype.h>

    int get_word(char *buf, int buf_size, FILE *fp){
        int len;
        char ch;

        while((ch = getc(fp)) != EOF && !isalnum(ch))
            ;

        if(ch==EOF) return EOF;

        len = 0;
        do{
            buf[len] = ch;
            len++;
            if(len >= buf_size){
                fprintf(stderr, "word too long.\n");
                exit(1);
            }
        } while((ch = getc(fp)) != EOF && isalnum(ch));

        buf[len] = '\0';
        return len;
    }

    int main(int argc, const char* argv[]){
        char buf[256];
        while(get_word(buf, 256, stdin) != EOF){
            printf("<<%s>>\n", buf);
        }

        return 0;
    }

- 在`main()`中，`buf`作为函数的参数传递，因为这里是在表达式中，所以`buf`可以解读成"指向数组初始元素的指针"
- 在`get_word()`中，可以像`buf[len]`这样操作`buf`的内容，那是因为它只是`*(buf+len)`的语法糖
- 一旦使用`buf[len]`还真让人感觉从`main()`传递过来的是`buf`这样的数组，显然这是一个 __错觉__，传递过来的只是指向`buf`的初始元素的指针（C是只能使用标量的语言）
    - 在`main()`中如果`sizeof(buf)`将得到265，而在`get_word()`中执行同样的语句，将得到指针类型的长度。
- 在C中，函数参数传递都是传值，向函数传递的都是参数副本，向`get_word()`传递的是指向`buf`初始元素的 __指针的副本__，但在`main()`和`get_word()`引用的却是`buf`本身，而不是`buf`副本，正如此，`get_word()`才能正确向`buf`填充字符串内容

#### 如何对数组进行值传递
在迫不得已的情形下，执意要将数组的副本作为参数进行传递，可以使用替代方法，将数组的所有元素整理成结构体的成员

### 声明函数形参的方法
针对上例，有人会将`get_word()`声明成如下`int get_word(char buf[], int buf_size, FILE *fp)`

__只有声明函数形参时，数组的声明才可以被解读成指针__

即使像`int func(int a[10])`这样定义了元素的个数，编译器也是无视的，还是解读成`int func(int *a)`

C是怎么使用内存的
=================

## 关于`scanf()`
在一般C语言书中，经常使用`scanf("%d", &hoge)`，`scanf()`不是以行单位对输入内容进行解释，而是对连续字符流进行解释（换行符也视为一个字符）。

`scanf()`连续的从流读入字符，并且对和格式说明符"%d"相匹配的部分进行变换处理，如输入"123\n"时，从流中取得123部分的内容，并对它进行处理，换行符依旧会残留在流中，后续如果存在`getchar()`就会吞食这个留下的换行符。

此外，当`scanf()`变换失败的时候，（比如尽管指定了%d，但输入的却是英文字符）将导致失败的部分遗留在流中。

在读入过程中有几个对象被成功地变换，则`scanf()`的返回值就为几。

为了避免后续字符的遗留影响后面的输入时，可使用如下方式：

<!--language: c-->

    char buf[256];
    int hoge;
    fgets(buf, sizeof(buf), stdin);
    sscanf(buf, "%d", &hoge);

## C的变量的种类
C语言的变量具有区间性的作用域，用语句包围的是作用域，`static`控制静态连接，`extern`控制外部连接。对于全局变量，作用域指文件作用域，链接指外部链接。对于程序员来说，这些方式都是控制命名空间的，没什么不同，统一使用“作用域”叫法


### 作用域
#### 全局变量
在函数之外声明的变量，默认的会成为全局变量。它在任何地方都是可见的。当程序被分割为多个源文件进行编译时，声明为全局变量的变量也是可以从其他源代码文件中引用的。

#### 文件内部的静态变量
就算对于像全局变量那样被定义在函数外部的变量，一旦添加了`static`，作用域只限定在当前所在的源代码文件中。通过`static`指定的变量（包括函数），对于其他源代码文件是 __不可见的__。

#### 局部变量
指在函数中声明的变量，局部变量只能在包含它的声明的语句块中被引用。局部变量通常在它所在语句块结束的时候被释放，如果 __不想释放__，可加上`static`进行声明。

### 存储期
#### 静态存储期
全局变量、文件内的`static`变量、指定`static`的局部变量都持有静态存储期，这些变量被统称为 __静态变量__，变量的寿命从程序运行时开始，到程序关闭时结束，一直存在内存的同一个地址上。

#### 自动存储期
没有指定`static`的局部变量，持有自动存储期，被称为 __自动变量__。在程序运行进入它所在语句块时（进入函数时）被分配内存区域，该语句块执行结束后这片内存区域被释放。

这个特征通常使用 __栈__ 的机制来实现。

#### 动态分配回收
通过`malloc`分配的领域，寿命一直延续到使用`free()`释放它为止，需要 __手工__ 处理。

### 变量在内存中区域
- 指向函数的指针、字符串常量 被配置在非常近的内存区域（只读）
- 函数内static变量、文件内static变量、全局变量等这些静态变量 也被配置在非常近的内存区域（只读）
- 接下来就是malloc()分配的内存区域
- 自动变量的区域离得很远，而且随函数调用（栈），会使用相同的地址

## 函数和字符串常量
### 只读内存区域
大多数操作系统都是将 __函数自身__ 和 __字符串常量__ 汇总配置在一个只读内存区域

### 指向函数的指针
将指向函数的指针保存在变量中的技术经常被运用在如下场合：

- GUI中的按钮控件记忆“当自身被按下的时候需要调用的函数”
- 根据“指向函数的指针的数组”（如`int (*func_table[])(double)`）对处理进行 __分配__

## 静态变量
静态变量总是在虚拟地址空间上占用固定的区域。

### 分割编译和连接
关于函数和全局变量，如果它们的名称相同，即使它们跨了多个源代码文件也被作为相同的对象来对待，进行这项工作的是一个被称为“链接器”的程序

为了在链接器中将名称结合起来，各目标代码大多都具备一个 __符号表__，在unix中，可使用`nm`命令窥视符号表中内容。

## 自动变量（栈）
### 函数调用究竟发生了什么
<!--language: !c-->

    #include <stdio.h>

    void func(int arg1, int arg2){
        int var3, var4;
        printf("func:&arg1..%p &arg2..%p", &arg1, &arg2);
        printf("func:&var3..%p &var4..%p", &var3, &var4);        
    }

    int main(void){
        int var1, var2;
        printf("main:&var1..%p &var2..%p", &var1, &var2);
        func(1, 2);
        return 0;
    }

C语言中，在现有被分配的内存区域之上以“堆积”的方式（向 __低地址位方向__ 堆积，栈不断的增长），为新的函数调用分配内存区域。在函数返回的时候，会释放这部分内存区域供下一次函数调用使用。

<!--language: plain-->

               ┌──────────┐
               │          │  main的局部变量 var1
    0xbfd243e4 ├──────────┤
               │          │  main的局部变量 var2
    0xbfd243e0 ├──────────┤
               │    2     │  func的形参 arg2
    0xbfd243dc ├──────────┤
               │    1     │  func的形参 arg1
    0xbfd243d8 ├──────────┤
               │          │  返回信息
    0xbfd243d4 ├──────────┤
               │          │  返回信息
    0xbfd243d0 ├──────────┤
               │          │  func的局部变量 var3
    0xbfd243cc ├──────────┤
               │          │  func的局部变量 var4
    0xbfd243c8 ├──────────┤
               │    │     │  
                    V

- 在调用方，参数 __从后往前__ 按顺序被堆积在栈中（为了支持可变长参数）
- 和函数调用关联的 __返回信息__（返回地址等）也被堆积在栈中
- 一旦函数调用结束，局部变量占用的内存区域就被释放，并且使用返回信息返回到原来地址
- __调用方__ 负责从栈中除去调用的参数
- 在函数调用时，需要为 __形参分配__ 新的内存区域，“C的参数都是传值，向函数内部传递的是实参的副本”，__其复制动作，就在这里发生__

#### 常见BUG
<!--language: c-->

    char *int_to_str(int int_val){
        char buf[20];
        sprintf(buf, "%d", int_value);
        return buf;
    }

像上面的代码是不能正常运行的，`buf`的内存区域在函数调用结束后就会被释放。

