> 2014-09-04

穿越时空的迷雾
=============

## 阅读ANSI C标准
```!c
#include <stdio.h>

void foo(const char **p){
    printf("%s\n", *p);
}

int main(void){
    char *s[] = {
        "abc","def"
    };
    foo(s);
    return 0;
}
```

这段代码是会发出编译警告的:  warning: passing argument 1 of foo from incompatible pointer type

实参`char *s`与实参`const char *p`是相容的，但实参`char **s`与实参`const char **p` __却是不相容__ 的

参数的传递过程类似赋值，而赋值形式的合法必须满足下列条件之一：

- 两个操作数都指向有限定符或无限定符的相容类型的指针
- 左边指针所指向的类型必须具有右边指针所指向类型的全部限定符

正因为第二个条件，使得函数调用中实参`char *s`与实参`const char *p`是相容的
> 左侧是指向有`const`限定符的`char`指针，右侧是一个指向没有限定符的`char`指针，`char`类型与`char`类型是相容的，左操作数所指向的类型具有右操作数所指向类型的限定符（此处是无），再加上自身的限定符（`const`）
>
> 并且在标准库中，所有字符串处理函数就是这样的

而`const char **p`读成`p is pointer to read-only char*`，指向有`const`限定符的`char`类型的指针的指针，即为 __没有限定符的指类类型__，而`char **s`读成`s is pointer to char*`，__它们所指向的类型不一样__，因此它们是 __不__ 相容的，违反了约束条件，编译器产生警告

### 容易混淆的const
`const`和`*`组合通常只用于在 __数组形式的参数中模拟传值调用__，它声明“给你一个指针，但你不能修改它”，将它想像成read-only

### 对无符号类型的建议
尽量不要使用无符号类型，以免增加不必要的复杂性，不要仅仅因为无符号数不存在负数而用它表示数量（如年龄）

尽量使用`int`那样有符号的类型，在涉及混合类型的复杂细节时，不必担心边界情况（如-1被翻译成非常大的正数）

只有在使用位段和二进制掩码时，才可以使用无符号数，应该在表达式中使用强制类型转换，使操作数均为有符号（或无符号），而不必由编译器来选择结果的类型

> `sizeof()`返回类型是`unsigned int`，需要小心



