概述
======

## 初识范式

所谓编程范式(programming paradigm)，指计算机编程的基本风格或典范模式，是编程者在创造虚拟世界时采用的 __世界观__ 和 __方法论__，编程是为了解决问题，而解决问题可以有 __许多种视角和思路__，其中普适且行之有效的模式被归结为范式。由于着眼点和思维方式不同，相应的范式自然各有侧重和倾向。

- 世界观：体现在语言的 __核心概念__ 中
- 方法论：体现在语言的 __表达机制__ 中

## 开发技术

- 任何概念和技术都不是孤立的，需要在 __纵向的时间__ 和 __横向的联系__ 中找准坐标
- 学习编程范式能增强编程语言的语感，否则一个惯用C语言的人只会写出'C式C++'，而不具备OOP的语感

### 库和工具包 vs 框架
- 库和工具包是为程序员带来 __自由__ 的，框架是为程序员带来 __约束__ 的
- __宏观管理__ 上选取一些框架以控制整体的结构的流程。利用控制反转(IOC)等机制实现对各模块的统一调度
- __微观实现__ 上利用库和工具包来解决具体的细节问题

### 设计模式 vs 架构
- 设计模式是软件的 __战术__ 思想，架构是软件的 __战略__ 决策
- 设计模式是针对某些经常出现的问题而提出的行之有效的设计解决方案，它侧重 __思想重用__，因此比框架更抽象，更普适，但多限于局部解决方案，没有框架的整体性。
- __惯用法(idiom)__，也是针对常发问题的解决方案，但 __偏重实现__ 而非设计，__与实现语言密切相关__，是一种更底层更具体的编程技巧
- 架构指一个系统的最高层次的 __整体结构和规划__，一个架构可能包含多个框架，而一个框架可能包含多个设计模式。

重要范式
=========

## 命令范式-一切行动听从指挥

### 命令式编程
冯.诺伊谩机运行机制的抽象

- 世界观是：程序是由若干行动指令组成的有序列表
- 方法论是：用变量来存储 __数据__，用语句来执行 __指令__

### 结构化编程

- 微观上：主张 __循规守矩__
- 宏观上：主张 __分而治之__
- 按结构化思想设计的流程图，每个模块大小适中、模块之间关系简明、模块内部线路清晰

## 声明范式-目标决定行动

## 对象范式-民主制社会的编程法则
## 并发范式-合作与竞争




抽象封装
==========

## 抽象思维
无论是编程范式风格上的差异，还是编程语言级别上的高低，皆源于各自提供的 __抽象机制__ 的不同

抽象就是做 __减法__（去粗取精）和 __除法__（异中求同，同类并归[乘法为同类复制]）

抽象有 __角度__ 之分，相同的实体经过不同角度的抽象，得到的模型会不同

分析与设计：

- 分析（理解问题领域，明确业务需求，制定出功能规范/非功能规范）；设计（制定出实现规范）；实现（完成编码）
- 分析阶段多采用 __性质导向式__ 抽象（定性，关注是什么what，而不是怎么样how）；设计阶段多采用 __模型导向式__ 抽象（定量），通过构造数据模型来满足系统的性质，实现功能规范
- 分析阶段前期（领域分析）只 __标识类的性质__（属性和关联），类的运算可有可无；分析阶段后期（应用分析）个体类的运算不如 __整体系统的动态行为__（用例图/活动图）重要；到设计阶段，__个体类运算__ 才是关注点之一

抽象机制：

- 参数抽象：函数的每一个参数都是一种泛化，是对它所代表所有可能值的一种抽象
- 规范抽象：通过规范使代码的功能与实现相分离，规范了服务提供方的义务，保障了服务享受方的权利

子类的先验条件可以弱化(接受更泛的参数)，后验条件可以强化(返回更细的返回值)，但不能反之

契约式设计的语言Eiffel/D，明确保障包括先验条件，后验条件，类不变量，副作用等在内的契约，语言引用assert就是为了支持契约式编程

五类基本抽象：

- 过程抽象：自定义运算的能力 将行为的逻辑属性与实现细节分离
- 数据抽象：自定义类型的能力 将数据的逻辑属性与表现细节分离
- 迭代抽象：自定义循环的能力 将集合遍历与元素的获取细节分离
- 类型层次：自定义类族的能力 将类型的公共行为与具体类型分离
- 多态抽象：自定义多态类型的能力 a抽象类型（类型的接口规范与实现代码分离）；b参数类型[泛型]（将类型与算法分离）

## 数据抽象

数据结构强调具体实现，多从实现者和维护者角度来考虑；抽象数据类型(ADT)强调抽象接口，多从设计者和使用者的角度来考虑

参数抽象使数据接口普适化，规范抽象使数据接口契约化

接口与实现分离，有利于开发时间的分离及开发人员的分离

C中以static函数表示内部函数

以接口为中心，强调对象行为，对象交互，属于OOD；以数据为中心，强调算法对数据的依赖，属于OOP；OOA则是描述问题，而非解决问题

可以将类理解为具有继承与多态的ADT

##　封装隐藏
信息隐藏是一种原则，封装是实现这种原则的一种方式

反射机制多用于单元测试、代码分析、框架设计等，常规应用很少使用

封装，不能直接返回类的内部对象（可变域对象mutable field object），用户调用方法后可直接进行操作，破坏了封装，C++中可使用const成员函数，其它语言考虑返回复制品

在设计类时，必须考虑在语义上是引用对象还是值对象：

- 值对象关心的是值，而非它的同一性，不希望不同的对象因共享相同的引用而导致同步修改，如果值对象是可变的，往往需要利用值拷贝防止因同一性而导致意外同步变化
- 引用对象重要的是同一性，而非值，不须要也不应该进行值拷贝

信息隐藏中的信息不仅仅是数据结构，还包括实现方式和策略

抽象接口
==========

## 软件应变
软件变化

- 出于内在需求而作的结构性变化，以改善软件质量为目的，包括重构、性能调优等
- 出于外在需求而作的功能性变化，以满足客户需求为目的

## 访问控制
友函数常用于运算符重载

一个类与其友类或友函数是联合关系而非主客关系，它们之间的互访与普通类内部成员互访没有本质的不同，甚至由于friend是单向授权的，反而是private的一种细化

一个类的方法能访问除this之外的其它同类对象的private成员，盖因访问控制是对静态代码的控制，而不是动态对象，以代码而非对象为边界

## 接口服务
提供的服务过多则不纯粹，过少则不完备

讲究服务的一致性与关联性

继承机制
============

## 继承关系
继承强调的是语言机制，子类继承父类；泛化强调的是概念关系，强调设计，父类后于子类提炼共同特性而设计的，称为超类

从子类到超类的泛化是概念抽象的过程，从超类到子类的特化是概念细化的过程，两种设计手法经常交替使用，属于上述五种基本抽象中的类型层级

java和C#只能继承接口，或既继承接口或继承实现，不能只继承实现

C++则可以做到，即private继承

但java或C#中可通过组合的方式而非继承的方式来达到对实现的重用

所以C++中的非公有继承可以看成匿名的非显性合成，只不过前者更具侵入性(可访问基类成员，重写方法)，后者更隐蔽与动态性(可被替换)

接口继承的作用不是为了让继承者重用，而是为了在合适的场合被调用，即不是为了代码重用，而是为了代码 被 重用

子类型不是子类(如int是long子类型，但不是它的子类)，子类也不一定是子类型(C++中private继承)，子类型关键是可代换性，即里氏代换(LSP)

接口继承必须建立在LSP之上，接口重用达到规范重用

多态抽象指一种类型可能具备多种类型的形式

如果只是为了重用基类的代码(权利)，而不希望重用它的接口(义务)，应该采用合成而不是继承方式

通用编程原则，尽可能弥合语法与语义之间的缝隙，以压缩代码臭虫的空间

继承与其说是is a的关系不如说behaves like，正如正方形是矩形，但行为并不一样，所以并不是继承关系

任何类型都应该保持或强化其超类型的规范，绝不能弱化规范

子类型 要求更少(接受更泛参数)，承诺更多(返回更细类型,协变返回类型)

JDK败笔 Properties继承Hashtable，Stack继承Vector


类偏重语法,强调实现方式，类型偏重语义，强调行为方式

OOP将现实中的概念抽象映射为程序中的类型，继承机制进一步将概念的分类体系映射为类型的层级结构


## 慎用继承

继承是一种静态（编译时建立）、显性关系（公开的）

描述了java与C#在对待重写时的区别


多态机制
=========

## 多态类型
GP中参数多态 OOP中子类型多态

前者让相同的实现代码应用于不同场合，后者让不同的实现代码应用于相同的场合

前者看重算法的普适性，后者看重接口与实现的分离度

都是在保证必要的类型安全的前提下，突破编译期间过于严苛的类型限制，保证代码灵活性、可维护性和可重用性

模板方法突出稳定坚固的骨架，策略模式突出是灵活多变的手腕

## 抽象类型
抽象数据类型的核心是数据抽象，抽象类型的核心是多态抽象

先以术养道，后以道御术

具体类型是创建对象的模板，抽象类型是创建类型的模块

一个是为对象服务的，一个是为类型服务的(它的抽象性正源于其服务的抽象性)

接口继承不是为了重用，而是为了被重用


值与引用
=========

## 语法类型
C++没用引用类型，但有&引用和*指针，具有引用功能，属于 引用端 的引用，而C#/java中引用类型是指 被引用端 的

语言中内存分配机制（按灵活递增）静态分配、栈分配、堆分配:

- 静态分配发生在编译期，为全局变量、静态变量、常数变量等安排空间
- 栈分配和堆分配均发生在运行期，但前者一般在编译期就可确定待分配内存的空间大小和生命周期（例外，C的alloca允许程序员在栈上分配动态大小的内存，但由编译器释放）
- 栈内存区主要用于存储局部变量或自动变量
- 堆内存区用于存储new运算符、malloc函数等动态分配而得的空间

栈分配效率高，通常每个线程都有独立的栈区，故栈变量天然是线程安全的，栈分配主要缺点须预知分配内存，而且栈区总容量有量，容易发生溢出。

堆分配更强大，更灵活，但复杂的算法影响了时间效率，内存碎片、元数据开销和可能的内存泄露等问题也影响了空间效率，此外程序员还需要担负更多的内存管理、线程安全等方面的责任。

一个C#/java的方法中

<!--language: csharp-->

    someType a=new someType();//someType为class

则a是局部变量分配在栈中，a指向的对象分配在堆中，a出了作用域就被编译器回收，而它指向的对象则被GC回收


C++中

<!--language: cpp-->

    someType* a=new someType();//分配在堆上  同java相似，只是多了*
    someType a=someType();//分配在栈上 或 someType a;

同C#的值类型相似，只是少了new

java中

<!--language: java-->

    class TestPassByRef{
      static void change(String str){str="new value";}
      public static void main(String[] args){
        String s="Old";
        change(s);
        System.out.println(s);
      }
    }

change的实际参数s是一个string引用，而不是string对象，让变量s换指另一个对象，并不能改变它当前所指对象

java按值传递对象的引用，并不支持按引用传递，因为所有对象都是引用类型，对象本身并不会被复制

C++的引用传递

<!--language: cpp-->

    void change(String& s)//传递对象的引用

C#的引用传递

<!--language: csharp-->

    void change(ref string s)//传进对象引用的引用

当一个对象给一个变量赋值或作为参数按值传递时，在C++中复制的是该对象的值，而java中复制的却是该对象的引用，因此，C++有专门的赋值运算符和复制构造函数，而java没有，java要达到复制对象值的目的，不能隐式的通过变量赋值或参数传递，只能显式的重新构造对象或clone/serilaization

java的按值传递无法解决：改变引用变量的目标对象，改变基本类型的值，将两个参数互换，同时返回多个计算值

以上只是语法，而语义才是设计者需要考虑的


<!--language: cpp-->

    //让值类型具有引用语义
    ValueType v1=someValue;
    ValueType& v2=v1;
    ValueType* v3=&v1;

    //让引用类型具有值语义
    ReferenceType r1=someObject;
    ReferenceType r2=(ReferenceType)r1.clone();

值语义变量的内存地址无关紧要，又称复制语义

引用语义变量的内存地址至关重要，通常用指针来实现，又称指针语义

OOP三在特性是：状态、行为、标识

没有标识的对象，则具有值语义

值语义一般地址无关性，时间无关性，通常是不可变的(immutable)

不可变为引用类型表示值语义提供是变通的语法支持 如java中的String/Integer/Boolean

C++中string是值类型的，但不是不可变的，但可以使用const来保证

值类型有时需要以引用类型的身份出现，就是装箱

不可变性加强了值语义

引用语义对象的改变是一种自我更新，值语义对象的改变是一种新旧更替

值语义的复件具有等效性，而引用语义的复件不具等效性

UML建模中，值对象多用于属性，引用对象多用于关联，值对象是附属的，被动的，引用对象是独立的，能动的

合成是基于值语义的包含，聚合是基于引用语义的包含


设计原则
=========

## 间接原则

任何计算机问题均可通过增加一个间接层来解决

像文件路径、URI、外键都具有间接指代作用

抽象层应当具有间接性

间接层也应当为抽象性，它应当是一个标准，标准是一系列规范的集合，而规范为显化的抽象

一个适当的中间层，在形式上表现为间接层，在实质上体现为抽象层

## 依赖原则

## 内聚原则
C/C++中静态全局变量只能在定义它的文件中被访问

接口隔离原则(ISP)主张，不应强迫客户依赖那些它们不用的方法

## 保变原则

设计模式
=============
## 创建模式
工厂方法，使用模板方法，子类重写各部件的创建，逻辑存在基类中

抽象工厂，如果把创建组件当成一种策略，接口中包括一系列多个产品的创建，可视为策略模式的应用，

APP使用接口，常使用依赖注入来获取工厂对象，逻辑存在APP中

创建者模式分离了对象的创建与对象的结构表示(无须一个抽象类型来表示产品)，故能做到工厂模式难以做到的事

接口中包含创建步骤，均返回void(导致用户无须知道各部件类型)，最后一步产品创建成功

工厂保护变化是产品制作的来源，创建者保护的变化是产品的制作细节

## 结构模式
抽象是前提，分解是方式，模块化是结果

层是按抽象层次进行的水平划分

不提倡向下转型，盖因把高抽象的类型转化为低抽象的类型，破坏了抽象层次的一致性

桥接模式的重点是分解，让本来结合紧密的接口与实现分离开，适配器模式重点是结合，让本来无关的类能合作共事

装饰者模式具有类型层级和聚合层级有交合的地方

适配器改变对象的接口而保持对象的职责，装饰者改变对象的职责而保持对象的接口

代理模式

C++中智能指针对java/C#意义：保证互拆（同步代理）、引用计数（计数代理）、写时拷贝或迟拷贝、延迟加载

值语义的对象适合享元模式

## 行为模式
OOP弱点，一个对象必须在获得另一个对象标识后方能向其发送消息
而Prolog或声明式编程无须如此，如shell中管道 `cat<file1|sort|uniq|comm -12 - file2>common`

职责链关心是职责的分解，更侧重行为

装饰者关心是职责的结合，更侧重结构

命令模式，请求的发送者与接收者在空间和时间上解耦
























