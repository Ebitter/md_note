概述
======

## 初识范式

所谓编程范式(programming paradigm)，指计算机编程的基本风格或典范模式，是编程者在创造虚拟世界时采用的 __世界观__ 和 __方法论__，编程是为了解决问题，而解决问题可以有 __许多种视角和思路__，其中普适且行之有效的模式被归结为范式。由于着眼点和思维方式不同，相应的范式自然各有侧重和倾向。

- 世界观：体现在语言的 __核心概念__ 中
- 方法论：体现在语言的 __表达机制__ 中

## 开发技术

- 任何概念和技术都不是孤立的，需要在 __纵向的时间__ 和 __横向的联系__ 中找准坐标
- 学习编程范式能增强编程语言的语感，否则一个惯用C语言的人只会写出'C式C++'，而不具备OOP的语感

### 库和工具包 vs 框架
- 库和工具包是为程序员带来 __自由__ 的，框架是为程序员带来 __约束__ 的
- __宏观管理__ 上选取一些框架以控制整体的结构的流程。利用控制反转(IOC)等机制实现对各模块的统一调度
- __微观实现__ 上利用库和工具包来解决具体的细节问题

### 设计模式 vs 架构
- 设计模式是软件的 __战术__ 思想，架构是软件的 __战略__ 决策
- 设计模式是针对某些经常出现的问题而提出的行之有效的设计解决方案，它侧重 __思想重用__，因此比框架更抽象，更普适，但多限于局部解决方案，没有框架的整体性。
- __惯用法(idiom)__，也是针对常发问题的解决方案，但 __偏重实现__ 而非设计，__与实现语言密切相关__，是一种更底层更具体的编程技巧
- 架构指一个系统的最高层次的 __整体结构和规划__，一个架构可能包含多个框架，而一个框架可能包含多个设计模式。

重要范式
=========

## 命令范式-一切行动听从指挥

### 命令式编程
命令式编程(imperative programming)是冯.诺伊谩机运行机制的抽象

- 世界观是：程序是由若干行动指令组成的有序列表
- 方法论是：用变量来存储 __数据__，用语句来执行 __指令__

> 语言的演化是渐进的，大多数语言追根溯源是汇编语言的升级，而作为与机器语言一一对应的汇编语言自然是命令式的，因而这种范式最为传统和普及。理论上说，完全可以有非命令式的机器语言存在，前提是计算机采用了特殊的硬件实现，比如非冯.诺伊谩结构的数据流机(dataflow machine)和规约机(reduction machine)，但这类计算机并未流行于市，相应的机器语言自然罕见

- 过程式编程(procedural programming)是指引入了过程、函数或子程序的命令式编程。现代语言命令式均具备此特征，故二者不加区分

### 结构化编程
结构化编程(structured programming，简称SP)，是在过程化编程的基础上发展起来的，本质是一种 __编程原则__，提倡代码应具有清晰的逻辑结构，以保证程序易于读写、测试、维护和优化。

> 在20世纪60年代首次软件危机中，它曾起中流砥柱。Pascal是遵循结构化编程原则设计而来的

- 微观上：主张 __循规守矩__，采用3种逻辑结构，限制goto使用
> goto语句可以跳到程序过程中的任一点，造成 _静态程序_ 与 _动态进程_ 之间的差异，影响程序可读性
- 宏观上：主张 __分而治之__，采用自项向下的设计
- 按结构化思想设计的流程图，每个模块大小适中、模块之间关系简明、模块内部线路清晰
- 根据结构化定理，任何程序都可以用顺序(concatenation)、选择(selection)和循环(repetition)等3种基本控制结构来表示。结构化编程就是在三种基本结构的基础上进行嵌套组合。

## 声明范式-目标决定行动
### 声明式与命令式区别
- 声明式编程由若干规范(specification)的声明组成，即一系列陈述句“已知这，求解那”，强调“__做什么__”，而非“怎么做”，声明式编程是人脑思维方式的抽象，利用数理逻辑或既定规范对已知条件进行推理或运算
> 声明式编程产生于人工智能的研究，主要包括 __函数式编程__(functional programming，简称FP)和 __逻辑式编程__(logic programming，简称LP)
- 命令式编程是 __行动导向__ 的，因而算法是显性而目标是隐性的；声明式编程(declarative programming)是 __目标驱动__ 的，因而目标是显性而算法是隐性的。

C(命令式)

<!--language: c-->

    int factorial(int n){
        int f = 1;
        for (; n > 0; --n) f *= n;
        return f;
    }

Lisp(函数式)

<!--language: lisp-->

    (defun factorial(n)
          (if (= n 0) 1
          (* n (factorial(- n 1)))))


Prolog(逻辑式)

<!--language: prolog-->

    // 0! 等于1
    factorial(0,1).
    // 若M等N-1且M!等于Fm且F等于N*Fm，则N!等于F
    factorial(N,F) :- M is N-1, factorial(M,Fm), F is N* Fm.

上述三种语言，C明确给出了阶乘的迭代算法，而Lisp仅描述了阶乘的递归定义，Prolog则陈述了两个关于阶乘的断言

> 当然C也可以递归实现，但 __命令式语言提倡迭代而不鼓励递归__，除尾递归(tail recursion)外，一般递归比迭代开销(overhead)大。相反 __声明式语言提供递归而不支持迭代__，迭代着眼微观过程，而递归放眼宏观规律

- 声明式编程让我们重回 __数学思维__：
    - 函数式编程类似代数的表达式变换和计算
    - 逻辑式编程则类似数理逻辑推理
    - 变量也如数学中一样，是抽象符号而非内存地址，没有赋值运算，不会产生变量被改写的副作用(side-effect)，也不存在内存分配和释放问题

- 声明式语言擅长于 __数理逻辑的应用__，如人工智能、符号处理、数据库、编译器等，对 __基于业务逻辑__ 的，尤其交互式或事件驱动型的应用，显然命令式语言更有用武之地

### 三种核心编程范式的比较

<!--language: table-->

    |范式  |程序    |输入    |输出    |程序设计|程序运行  |
    |------|--------|--------|--------|--------|----------|
    |命令式|自动机  |初始状态|最终状态|设计指令|命令执行  |
    |函数式|数学函数|自变量  |因变量  |设计函数|表达式变换|
    |逻辑式|逻辑证明|题设    |结论    |设计命题|逻辑推理  |

### 声明式的其它形式
- C#中attribute，java中annotation采用具有声明式特征的 __属性导向式__ 编程(Attribute-Oriented Programming，简称@OP)。
- 数据库语言SQL、样式语言XSLT、CSS、__标记语言__ HTML、XML、SVG、__规范语言__ IDL(Interface Description Language)等都是声明式的，它们大多是领域特定语言，且不少并非图灵完备。
- Prograph、SISAL等数据流语言，采用 __数据流编程__(Dataflow Programming)
- Oz、CHIP等支持与逻辑式编程相交的 __约束性编程__(Constraint Programming)

## 对象范式-民主制社会的编程法则
OOP(Object-Oritented programming)是一种计算机编程模式，它将对象作为问题空间的基本元素，利用对象和对象间的相互作用来设计程序，所谓对象，是实际问题中实体的抽象，具有一定的属性和功能。

- OOP虽然是在命令式的基础上发展起来的，但其核心思想可泛化为：__以数据为中心组织逻辑__，将系统视为相互作用的对象集合，并利用继承与多态来增强可维护性、可扩展性和可重用性
- 命令式、函数式和逻辑式互相平行，__而OOP与它们正交__：Clos成为OO版的Lisp，Prolog也有融入OO特征的扩充，如visual prolog
- OOP最适用于大型复杂的、交互式的，与现实世界密切相关的系统，小型应用、数学计算、符号处理等方面并无优势。
- 将可维护性、可扩展性和可重用性与OOP划等号，是只见树木，不见森林，因为那是所有范式和语言的共同目标。
    - C语言中，信息隐藏可用 __static__ 来实现，继承可用 __合成__ 来代替，多态可用 __函数指针__ 来实现。

### 过程式编程与OOP区别
- 过程式编程的理念是以过程为中心，自顶向下、逐步求精，类似数学证明中分析法，执果索因的逆推法；OOP则相反，以数据为中心，自底向上、逐步合并，类似数学证明中的综合法，执因索果的正推法。
- 过程式编程，树干改变容易导致树枝相应改变，一旦 __用户需求发生变化__，维护起来不易，而OOP从树叶开始设计，离用户需求较远，__抽象程序较高__，受波及程序较小，更易维护和重用
- OOP以对象为基本模块，使设计更人性化，接近人类的 __认知模式__：`牛.吃(草)` vs `吃(牛,草)`
- 与其说OOP重用性，不如说更具 __易用性__，C函数不像Java对象，本身没有状态，只有依靠参数传递或外部变量来维持相关函数之间的联系，而OOP就是将 __相关函数用数据粘合__，重新包装后再贴上对象标签。
- 过程式编程的模块以函数为单位，而OOP的模块以对象为单位，函数是被动的实体，对象是主动的实体
    - 过程式程序的世界是君主制，等级分明，听命于上级，对下级发号施令，最终为国王服务。
    - OO程序是民主制，所有对象独立而平等，有权保护自己财产与隐私，向他人寻求服务，有义务为他人提供承诺的服务，公民间通过信息交流来协作完成任务

### OO三大特性
- 封装：使公民拥有 __个体__ 身份，须对自己负责
- 继承：使公民拥有 __家庭__ 身份，须对家庭负责
- 多态：使公民拥有 __社会__ 身份，须对社会负责

## 并发范式-合作与竞争
真正的并发式编程(concurrent programming)，不只是调用线程API，使用`synchronized`、`lock`之类那么简单，从宏观架构设计，到微观的数据结构、流程控制乃至算法，比串行式编程都可能发生变化

- 并发式编程以 __进程为导向__ 、以 __任务为中心__ 将系统模块化
- 以 __资源共享与竞争__ 为主线，意味着程序设计将围绕进程的划分与调度、进程间的通信与同步等来展开
> 同步(synchronization)只在采用 __共享内存__(shared memory)的并发模型中需要，采用 __消息传递__(message passing)的并发模型中(如Erlang)并不需要
- 它同OO一样，与3大核心范式正交，并发式进程个数为1即为传统串行式编程，对象个数为0即传统的数据类型。

### 合理并发式设计的考量
- 软件易于重用、维护、测试
- 公平有效地利用资源，优化程序性能如增大吞吐量、减少响应时间、提高效率等
- 保障进程安全，防止竞态条件(Race Condition)
- 保持进程活性，避免死锁、饥饿、活锁、资源枯竭
- 减少锁开销，上下文切换等带来的性能损失
- 妥善处理多进程在算法、调试方面带来的复杂性

### 编程语言对并发的支持
- Ada、Java、C#在 __语言级别__ 上支持并发，在语法上对并发编程有一定的支持
- C、C++选择交由操作系统处理，除关键字`volatile`外，主要靠 __库函数__ 支持
- 专门为并发式而设计的，如Erlang

### 与OO区别
- 并发式以任务为单位，而OO以对象为单位
- 子系统中交流与合作时，并发式以竞争为主题，而OO以服务为主题

## 五种范式小结

<!--language: table-->

    |范式    |体系      |模块    |模块关系    |
    |--------|----------|--------|------------|
    |过程式  |君主体系  |过程    |授命与听命  |
    |函数式  |数学体系  |函数    |替换与合成  |
    |逻辑式  |逻辑体系  |断言    |归纳与演绎  |
    |对象式  |民主体系  |对象    |交流与服务  |
    |并发式  |生产体系  |进程    |竞争与合作  |

常用范式
=========
## 泛型范式-抽象你的算法

- 泛型编程(Generic Programming，简称GP)是 __算法导向__ 的，即以算法为起点和中心点，逐渐将其所涉及的 __概念__(数据结构、类)内涵模糊化、外延扩大化，将其所涉及的 __运算__(函数、方法、接口)抽象化、一般化，从而 __扩展算法的适用范围__。

- 基本思想是：将算法与其作用的数据结构分离，并将 __后者__ 尽可能泛化，这种泛化是基于模板(template)的 __参数多态__(parametric polymorphism)，相比OOP的基于继承(inheritance)的 __子类型多态__(subtyping polymorphism)，普适性更强，效率也更高。但用法稍微复杂一些，可读性稍差一些。

### 泛型实现机制
- C++和D采用类型模板(template)，最著名代表是STL(Standard Template Library)
- Java采用类型擦除(type erasure)
- C#采用类型具化(reification)

C++(泛型编程)

<!--language: cpp-->

    template <typename T>
    T max(T a, T b){
        return (a > b) ? a : b;
    }

C(宏定义)

<!--language: c-->

    #define max(a,b) ((a) > (b) ? (a) : (b))

在C中可用宏定义(macro definition)来实现，但无法保证类型安全，而C++模板兼顾类型安全和代码重用，并且由于在编译期间展开，效率上也不损失，且由于C++支持运算符重载，一切定义了`>`运算的数据类型均可调用`max`函数

### STL三要素
- __算法__(algorithm)：一系列切实有效的步骤
- __容器__(container)：是数据的集合，可理解为抽象的数组
- __迭代器__(iterator)：是算法与容器之间的接口，可理解为抽象的指针或游标


### STL示例
- 请问它们共同之处，能否共享代码
    - 从一个整数数组中随机抽取十个数，对其中的素数求和
    - 将一个无序整数集中所有的完全平方数换成其平方根
    - 从学生成绩表中，列出门门都及格且平均分在70分以上的学生名单
    - 在一个着色二元树中，将所有红色结点涂成蓝色
    - 将一个字符串从倒数第3个字符开始反向拷贝到另一个字符串中
    - 每从标准输入读取一个非数字的字符X，于标准输出打印"X不是数字字符"

- 只有抽象出表面的数据，算法的脊梁才能显现，以上几题运算泛型思维，可发现它们共性：对指定集合中满足指定条件的元素进行指定处理

<!--language: cpp-->

    template <class Iterator, class Act, class Test>
    void process(Iterator begin, Iterator end, Act act, Test test){
        for (; begin != end; ++begin)
            if (test(*begin)) act(*begin);
    }

比起前面`max`模板，这里连元素的数据类型T都没有，因为元素被容器封装了，只需通过它的迭代器参与算法：

- 泛化了 __容器__，可以是数组、列表、集合、映射、队列、栈、字符串等
- 泛化了 __元素__，可以是任何数据类型
- 泛化了 __处理方法和限定条件__，可以是任何函数，甚至是函子(functor)－－自带状态的函数对象，即除了泛化概念，还能 __泛化行为__
- 泛化了 __迭代器__，可以从前往后移动，也可以从后往前移动，可以来回移动，可以随机移动，可以按任意预先定义规律移动

以下为第6题实现：

<!--language: cpp-->

    #include <iostream>
    #include <vector>
    #include <fstream>
    #include <iterator>

    using namespace std;

    template <class Iterator, class Act, class Test>
    void process(Iterator begin, Iterator end, Act act, Test test){
        for (; begin != end; ++begin)
            if (test(*begin)) act(*begin);
    }

    bool notDigit(char c){
        return (c<'0') || (c>'9');
    }

    void printNondigit(char c){
        cout << c << " not digit" <<endl;
    }

    int main() {
        process(istream_iterator<char>(cin), istream_iterator<char>(), printNondigit, notDigit);

        return 0;
    }

完全看不到IO读取的过程，也看不到迭代循环，让人摆脱了底层编码细节，在更高 __更抽象__ 的层次上进行编程设计，用一种新的视角去审视问题。

## 超级范式-提升语言级别
元程序 __将程序作为数据对待__，能自我发现、自我赋权和自我升级，有着其他程序所不具备的自觉性、自适应性和智能性，是一种更高级的程序。

### 元编程
- 模板元编程(Template Metaprogramming)与泛型编程密切相关但自成一派，隶属于另一种编程范式－__元编程__(Metaprogramming，简称MP)

<!--language:!cpp-->

    #include <iostream>
    using namespace std;

    template <int N>
    struct factorial{
        enum { value = N * factorial<N-1>::value};
    };

    template <>
    struct factorial<0>{
        enum { value = 1};
    };

    int main(){
        cout << factorial<5>::value << endl;
        return 0;
    }

这里阶乘的值是在 __编译时__ 而非运行时计算出来的，是以模板形式通过编译器生成了新的代码，并在编译期间获得执行。

- Lex和Yacc编写编译器和解析器的工具
- 除上述在编译期间生成源代码的 __静态元编程__，还有在运行期间修改程序的 __动态元编程__，如JavaScript用字符串构建`Function`，Ruby提供了`define_method`、`instance_eval`等元编程方法


### DSL

- 领域特定语言DSL，灵活方便地处理客户逻辑，比通用语言更简单、更抽象、更专业、更接近自然语言和声明式语言，开发效率提高
- Hiberate中HQL就是典型的DSL，通过ANTLR来解析(ANother Tool for Language Recognition，能生成C,C++,Java,C#,Python等)
- 语言导向式编程(Language-Oriented Programming，简称LOP)，在建立一套DSL体系之后，直接用它们来编写软件

### 代码生成
- 各种IDE通过向导、拖放控件等方式自动生成源代码；UML建模工具将类图转换为代码；Servlet引擎将JSP转换为Java代码等
- 生成的代码，不需要被管理（小操作造成生成上差异很大，削弱版本控制意义），而元程序数据需要版本化，简明而直观
> 同理，没法记录的东西，不方便自动化与重放，比如调试，用单元测试与log取而代之
- 自动生成源代码的编程也属于另一种编程范式－产生式编程(Generative Programming)，只是它更看重代码的生成，而元编程看重的是生成代码的可执行性。

## 切面范式-多角度看问题

### 抽象与分解
- 不良代码的病征：
    - __结构混乱__，或聚至纠缠打结、或散至七零八落
    - __代码重复__，叠床架屋、臃肿不堪
- 有效方式是 __抽象与分解__：从问题中抽象出一些关注点，再以此为基础进行分解。抽象是 __前提__，分解是 __方式__，模块化是 __结果__
    - 将程序分别抽象为过程、函数、断言、对象和进程，就依次成为过程式、函数式、逻辑式、对象式和并发式
    - 抽象出算法后与数据分离，就成了泛型式
    - 切面式的AOP将程序抽象分解为 __切面__，以切面为模块
- 抽象与分解原则：__单一化，正交化__。每个模块职责明确专一，模块间相互独立，高内聚低耦合(high cohesion & low coupling)。
    - 此原则相当普适，是分析复杂事物的一种基本方法，在数学和物理中应用广泛：质因式分解、正交分解、谱分解
    - 在数学中互为正交的两个向量在彼此方向上投影为零，意味着彼此独立、互不影响

### Soc与DRY
Soc(Separation of Concerns)即关注点分离，DRY(Don't Repeat Yourself)即尽量减少重复代码。

### Aspect
- 切面Aspect，描述的是横切关注点(cross-cutting concerns)，是与程序的 __纵向主流__ 执行方向 __横向正交__ 的关注焦点。
- 调用某些对象的方法、读写某些对象的域、抛出某些异常等前后需要用到统一的业务逻辑，诸如日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理等，难以实现Soc与DRY时
- AOP将每类横切关注点封装到单独的Aspect模块中，将程序中的一些执行点与相应的代码绑定起来
    - 单个的执行点称为 __接入点__(join poing)，如调用某个对象的方法前后；
    - 符合预先指定条件的 __接入点集合__ 称为 __切入点__(pointcut)，如所有以set为命令开头的方法；
    - 每段绑定的代码称为一个 __建议__(advice)
- __接入点 vs 切入点__
    - 接入点是点，切入点是面，advice定义了切入点上，执行于接入点处，共享一段附加代码的接入点组成了一个切入点
    - 切入点一般用条件表达式来描述，不仅有广泛性，还有预见性（以后新增的代码如果含有满足切入点条件的接入点，advice代码便自动附着其上）

### AOP与OOP
OOP只能沿着继承树的纵向方向重用，而AOP则弥补了该不足，可以在横向方向重用，AOP不是OOP的分支，也不能说超越了OOP，而是一种补充，尽管AOP并不局限于OOP语言

### AOP实现机理
如果一个程序是一个管道系统，AOP就是在管道上钻一些孔，在每个孔中注入新的代码流。因此AOP的实现关键是将advice的代码嵌入到主体程序中，术语称 __编织__(weaving)。

- 静态编织，通过修改源码或字节码(bytecode)在编译期(compile-time)、后编译期(post-compile)或加载期(load-time)嵌入代码，可能用到元编程和产生式编程
- 动态编织，通过代理(proxy)等技术在运行期(run-time)实现嵌入
- 工具：扩展性语言AspectJ、AspectC++、Aspect#；框架AspectWerkz、Spring等

## 事件驱动-有事我叫你,没事别烦我
侦查事件与响应事件两项任务进行了正交分解，降低了软件的耦合度和复杂度。

### 流程驱动 vs 事件驱动

采用主动去轮询(polling)，行为取决于自身的观察判断，是流程驱动的，符合常规的流程驱动式编程(Flow-Driven Programming)的模式，采用被动等通知(notification)，行为取决于外来的突发事件，是事件驱动的，符合常规的事件驱动式编程(Event-Driven Programming，简称EDP)的模式

### 事件的类型
- 基于事件驱动的系统一般提供两类的内建事件(built-in event)：
    - 底层事件(low-level event)或称原生事件(native event)，在GUI系统中，这类事件直接由鼠标、键盘等硬件设备触发
    - 语义事件(semantic event)，一般代表用户的行为逻辑，是若干底层事件的组合，比如鼠标拖放多表示移动被拖放的对象，由鼠标按下、鼠标移动、鼠标释放三个底层事件组成
- 除此之外，还有一类用户自定义事件(user-defined event)，可以是在原有的内建事件的基础上进行的包装，也可以是纯粹的虚拟事件(virtual event)
- 除外界激发的自然事件(natural event)，有时程序员需要主动激发一些事件，比如模拟用户鼠标点击或键盘输入(createEvent,trigerEvent)，称为合成事件(synthetic event)

### Windows消息机制

<!--language: c-->

    ...WinMain(...){
        // 第一步，注册窗口别
        ...;
        windowClass.lpfnWndProc = WndProc; // 指定该类窗口的回调函数

        windowClass.lpszClassName = windowClassName;
        RegisterClassEx(&windowClass);

        // 第二步，创建一个上述类别的窗口
        CreateWindowEx(..., windowClassName, ...);
        ...;

        // 第三步，消息循环
        while (GetMessage(&msg, NULL, 0, 0) > 0) { // 获取消息
            TranslateMessage(&msg); // 翻译消息
            DispatchMessage(&msg); // 分派消息
        }
    }

    // 第四步，窗口过程（处理消息）
    ...WndProc(..., msg, ...){
        switch (msg){
            case WM_SIZE: ...; // 用户改变窗口尺寸
            case WM_MOVE: ...;
            case WM_CLOSE: ...;
            ...;
        }
    }

- 消息是Windows内部最基本的通信方法，事件需要通过消息来传递，是消息的主要来源，每当用户触发一个事件，系统将其转化为消息并放入相应程序的消息队列(message queue)中，先入系统消息队列，再放入应用程序消息队列。
- `DispatchMessage`如何联系到`WinProc`？`DispatchMessage`的消息参数含有事发窗口的句柄(handle)，从而可以得到窗口过程`WinProc`，`(WNDPROC)GetWindowLong(msg.hwnd, GWL_WNDPROC)`，而当初创建窗口时指定了窗口类别，后者又绑定了窗口过程。
- 编程者自己写的应用层函数`WinProc`，却不直接调用它，而是通过库函数间接调用，这类函数称为：回调函数(callback)
- 消息循环不依赖于应用程序，完全可提炼出来作为library一部分，MFC就作了此处理
，假设窗口过程由应用程序直接调用，那么消息循环中代码将不具独立性，__无法作为公因子分解出来__

### 回调机制

- 函数指针是C和C++用来实现callback的一种方式，此外抽象类、接口、C++中的泛型函子(generic functor)和C#中的委托(delegate)都可以实现callback

![prog_paradigm_callback](../../../imgs/prog_paradigm_callback.png)

- 在软件模块分层中，低层模块为高层模块提供服务，并且不能依赖高层模块，以保证其可重用性；另一方面，通常被调用者(callee)为调用者(caller)提供服务，调用者依赖被调者，两者结合，决定了低层模块多为被调用者，高层模块为调用者，但并不总合适，低层模块为了追求更强的 __普适性和可扩展性__，有时也有调用高层模块的需求

<!--language: java-->

    String[] strings = {"Please", "sort", "the", "strings", "in", "REVERSE", "order"};
    Arrays.sort(string, new Comparator<String>(){
        public int compare(String a, String b){
            return -a.compareToIgnoreCase(b);
        }
    });

- callback使得Array.sort不再局限于自然排序，允许用户自行排序规则，大大提高了算法的重用性

### 同步回调 vs 异步回调
- 字符串数组排序中，callback作为参数传入低层的函数后，很快就在该函数体中被调用；而窗口程序中，callback则先被储存起来，至于何时被调用是未定之数。前者称为同步(synchronous)回调，后者称为异步(asynchronous)回调
- 都使用调用者，不再依赖调用者，将二者从 __代码上解耦__，异步调用更将二者从 __时间上解耦__

![prog_paradigm_asyn_callback](../../../imgs/prog_paradigm_asyn_callback.png)

- 图中处于低层的软件平台是在win32 API基础上的改增，主循环沉淀下来，而且将存储callback的过程封装在一个注册函数中，整个流程的 __控制权__ 已从应用程序的主程序 __转移到底层平台__ 的主循环中，符合好莱坞原则(Don't call us, we'll call you)

### 控制反转
好莱坞原则中，经纪公司处于主导地位，艺人们处于受控状态，这便是控制反转(Inversion of Control，简称IoC)

- 一般库中用callback只是局部的控制反转
- 框架则将IoC机制用到 __全局__，程序员牺牲了对应用程序流程的主导权，换来的是更简洁的代码和更高的生产效率。
- 框架的可扩展性，通过 __插件__(plugin)体系达到

![prog_paradigm_ioc](../../../imgs/prog_paradigm_ioc.png)

### 依赖反转与依赖注射
- __依赖反转__ 原则(Dependency-Inversion Principle，简称DIP)更加具体
    - 高层模块不应依赖低层模块，它们都应依赖于抽象
    - 抽象不应该依赖于细节，细节应依赖抽象

- __依赖注射__(Dependency Injection，简称DI)，动态地为一个软件组件提供外部依赖
- 控制反转、依赖反转和依赖注射的 __主题是控制与依赖，目的是解耦、方法是反转、而实现这一切的关键是抽象接口__
    - 为什么是抽象接口，而不是回调函数？-
    “回调”强调的是行为方式－低层反调高层，而“抽象接口”强调的是实现方式－正是由于接口具有抽象性，低层才能在调用时无须考虑高层的具体细节，从而实现控制反转

### 事件驱动式可伸缩性
可伸缩性(scalability)指从容应对工作量增长的能力，常与性能(performance)等指标一并被考量

- 控制反转的主要作用是降低模块之间的依赖性，从而降低模块的耦合度和复杂度，提高软件的可重用性、柔韧性和可扩展性，但对可伸缩性并无太大帮助

- 控制反转导致了事件驱动式编程的被动性(passivity)。事件驱动式还具有异步性(asynchrony)的特征，这是由事件的不可预测性与随机性决定的

- 一个应用中存在一些该类特质的因素，比如频繁出现堵塞呼叫(blocking call)，不妨考虑包装为事件，让堵塞呼叫暂时脱离主进程，事成之后再利用事件机制申请重返原进程，这种 __异步事件__ 式将连续的进程中 __独立且耗时__ 的部分抽取出来，从而减少随机因素造成的资源浪费，提高系统的 __性能和可伸缩性__

- __独立__ 是异步的前提，__耗时__ 是异步的理由，随机只是副产品，一个独立且耗时的子过程，通常结束时间也是不可预期的。

### 事件驱动式模型
- 三步曲
    - 事件处理器(event handler)或事件监听器(event listener)：负责处理事件，经注册方能在事发时收到通知
    - 注册事件处理器
    - 事件循环(event loop)：负责侦查事件、预处理事件、管理事件队列和分派事件，无事时默默等待，有事时立即响应

    > 许多IDE图形编辑器在程序员点击控件后，能自动生成事件处理器的骨架代码，还注册步骤也免除了

    > 自行设计事件系统时，需要决定采用事件驱动是否合适？如果合适，__如何设计事件机制__？包括事件定义、事件触发、事件侦查、事件转化、事件合并、事件调度、事件传播、事件处理、事件连带(event cascade 即处理过程中又产生新事件)等一系列问题


![prog_paradigm_event_driven](../../../imgs/prog_paradigm_event_driven.png)

- 典型模型
    - 事件处理器事先在关注的事件源上注册，后者不定期的发表事件对象，经过事件管理器的转化(translate)、合并(coalesce)、排队(enqueue)、分派(dispatch)等集中处理后，事件处理器接收到事件并对其进行相应处理
    - 事件处理器随时可注册或注销事件源，意味着二者之间的关系是 __动态__ 建立和解除的
    - 通过事件机制，事件源与事件处理器之间建立了 __松耦合__ 的多对多关系
    - 事件处理器与事件源是server-client模式，每个服务方与客户方会话是 __异步__ 的


- __发行订阅__ 模式(publish-subscribe pattern)正是 __观察者__ 模式(observer pattern)的别名，一方面可看作简化或退化的事件驱动式，另一方面可看作事件驱动式的核心思想
    - 该模式省略了事件管理器部分，由事件源直接调用事件处理器的接口，简明易用，但威力有限，缺少事件管理、事件连带等机制
    - MVC(Model-View-Controller)架构正是它在架构设计上的一个应用

重温范式
=========
每种范式都代表一套独特而有效地解决问题的思想和方法，掌握范式对编程语感的提升：
    - 编程语言的语法、语义等都是从编程范式的树根衍生而出的树叶，把握了这种脉络和节奏，代码才会如音乐般韵律有致
    - 每个范式擅长的问题域不尽相同，只有博闻广知，方可扬长避短，程序才会如行云流水般流畅自然。

## 函数范式-精巧的数学思维
函数式的数学背景是 __λ-演算__(lambda calculus)，也是图灵完备的

### 函数是头等公民

快速排序java版本

<!--language: java-->

    public class Sorter{
        public static<T extends Comparable<? super T>> void qsort(T[] list){
            qsort(list, 0, list.length -1);
        }

        private static<T extends Comparable<? super T>> void qsort(T[] list,
         int low, int high){
            if (low >= high) return;

            int i = low -1, j = high + 1;
            T pivot = list[low];

            for (;;){
                do { ++i; } while (list[i].compareTo(pivot) < 0);
                do { --j; } while (list[j].compareTo(pivot) > 0);

                if (i >= j) break;

                T tmp = list[i]; list[i] = list[j]; list[j] = tmp;
            }

            qsort(list, low, j);
            qsort(list, j + 1, high);
        }
    }

快速排序Haskell版本

<!--language: haskell-->

    qsort :: (Ord a) => [a] -> [a]　　-- 函数声明
    qsort[] = []　　　　　　　　　　　-- 递归终点
    qsort(pivot : rest) =
        -- 对前现的子列递归
        qsort[x| x <- rest, x < pivot]
        ++ [pivot]
        -- 对后面的子列递归
        ++ qsort[x| x <- rest, x >= pivot]

- 上面java代码很难再精简了，但与Haskell相比还是太冗长了，后者省去了所有赋值、迭代的流程控制，只有单纯的递归，反映了典型的函数式特征。
> Hakell函数声明可以省略，但出于可读、性能、调试等原因，最好保留
- 前者须指定计算过程，后者只须指定计算的原则，一个重微观过程，一个重宏观的方向

<!--language: haskell-->

    (filter (< pivot) rest)

- filter是过虑，将列表rest中元素进行筛选，条件是小于基准元素
- `(<pivot)`也是一个函数，函数式一个重要特征：函数是头等公民(first-class citizen)，可作传递参数，可作为表达式的值，可嵌入数据结构，也可与某变量绑定，与普通的基本数据类型毫无二致。这类函数叫 __高阶函数__ (higher-order function)
> callback无非将函数作为参数来传递，本质是将代码当数据来使用，属于高阶函数

C# lambda版本

<!--language: csharp-->

    IEnumerable<T> qsort<T>(IEnmerable<T> list) where T :
    IComparable<T>{
        if (list.count() <=1) return list;
        var pivot = list.First();
        return qsort(list.Where(x=>x.CompareTo(pivot)<0))
            .Concat(list.Where(x=>x.CompareTo(pivot)==0))
            .Concat(qsort(list.Where(x=>x.CompareTo(pivot)>0)));
    }

总体思想还是函数式的

### 函数的无副作用
- 函数式还有一个重要特征：无副作用或尽量减少副作用，一个函数在被调用前后保持程序的状态不变，不会改变非局部变量的值，不会改变传入的参数，也没有IO操作
> 没有副作用的称为纯函数式(purely functional)，如Haskell、SISAL；有副作用的称为非纯函数式(impurely functional)，如Lisp、ML，不过Haskell等语言也可通过monad来实现包括IO在内的副作用

- 什么状态都不变，函数还有什么用？命令式程序比作状态自动机，其运行过程就是不断的修改机器的状态，而函数式程序则是进行 __表达式变化__，一般不会改变变量的值。其实函数式并非完全不改变内存，__只不过改变的是栈内存__(stack)而已，换言之，无副作用函数的作用关键在于其估值结果（返回值）

- 没有副作用的函数易于重构、调试和单元测试；代码有效性与函数顺序无关，方便并发处理和优化处理
> 比如`f(x)*g(y)`，由于无副作用，`f(x)`和`g(y)`估值过程是独立的，估值顺序也不重要，理论上可以并行计算

### 函数的惰性求值

- 另外还可利用惰性求值(lazy evaluation)：上例中如果`f(x)`为零，那么不用计算`g(y)`了

<!--language: bash-->

    grep the BigFile.txt | head
    grep the BigFile.txt > tmpfile; head tmpfile

- 第一行是unix管道(pipe)，grep的输出是head的输入，__后者不用等到前者执行完毕才启动，只要后者获得足够数据，前者便停止执__。如果没有管道只能使用第二行代码了
- 类似的，通常计算`f(g(x))`的值，须计算完`g(x)`后才能将所有值代入函数f，有了惰性求值机制，__`g(x)`的计算完全由函数`f`的需求来驱动__，避免做无用功，此为惰性之所在
- 惰性求值不仅能节省有限的时间，还能超越无限的时间`g(x)`甚至可以永不退出，从而可能产生无穷的输出结果集供函数`f`使用
- 没有副作用的函数是引用透明的(referntial transparency)，即一个表达式随时可以用它的值来替换，因为一个表达式同样的输入一定是相同的输出

## 逻辑范式-当算法失去了控制
算法=逻辑+控制，其中逻辑是算法的核心，控制主要用于改进算法的效率

快速排序Prolog版本

<!--language: prolog-->

    /* 定义划分法 */
    partition(_,[],[],[]).    /* 划分递归终点 */
    /* 比基准小的归入Small */
    partition(Pivot, [X|Rest], [X|Samll], Big) :-
       X < Pivot, partition(Pivot,Rest,Samll,Big).
    /* 比基准大的归入Big */
    partition(Pivot, [X|Rest], Samll, [X|Big]) :-
       X >= Pivot, partition(Pivot,Rest,Samll,Big).

    /* 定义排序法 */
    qsort([],[]).             /* 排序递归终点 */
    qsort([Pivot|Rest],Sorted) :-
    partition(Pivot,Rest,Samll,Big),  /* 按基准划分子列 */
          qsort(Samll,SortedSamll),   /* 对前面的子列递归 */
          qsort(Big,SortedBig),       /* 对后面的子列递归 */
          /* 子列合并 */
          append(SortedSamll,[Pivot|SortedBig],Sorted).

- Prolog代码由一系列 __事实__(fact)、__规则__(rule)和 __查询__(query)语句组成的，事实与规则是公理，查询就是待证的定理
- 大写字母或下划线开头的标识符是变量，其他的是常量或函数；`:-`等价于if，逗号`,`等价于and
- `bachelor(X) :- unmarried(X), male(X).`如果一个人未婚且为男士，就是光棍
- 过程式代码在描述规则时，会有许多嵌套与顺序要求，如果增加规则时，许多代码得改写，而Prolog只需 __引入新的规则和事实即可，不会影响原来的代码__。
- 逻辑式 __没有明显的输入、输出之分__，能倒过来去查询
- 逻辑式编程模拟人类的逻辑思维，在机器证明、专家系统、自然语言处理、博弈等人工智能领域，以及知识管理、智能决策分析方面大显身手，适合 __基于规则__(rule-based)，而不是基于状态(state-based)的应用
> Prolog cafe和P#分别将Prolog转化为java和C#代码

## 汇总范式
### 设计模式vs编程范式
- 设计模式一般针对某一特定场景的问题，而编程范式针对的是广泛得多的问题领域，通常有一整套的思想和理论体系，具有全局性、系统性和渗透性
- 同样的思想用在 __整体结构设计__ 上，则称为架构模式；用在 __局部模块的细节实现__ 上，则称设计模式；用在 __引导编程实践__ 上，则称为编程范式。
- 设计模式是遵循设计原则的一些具体技巧，以保证代码的可维护性、扩展性和可重用性为目的，它重在设计，对语言一般没有要求。但编程范式则不同，对语言往往有专门的要求，通常会所某某范式的语言，事实上，语言本来就是围绕其所倡导的核心范式来设计的。

### 常见的编程范式

![prog_paradigm_lang1](../../../imgs/prog_paradigm_lang1.png)

![prog_paradigm_lang2](../../../imgs/prog_paradigm_lang2.png)

![prog_paradigm_lang3](../../../imgs/prog_paradigm_lang3.png)

![prog_paradigm_lang4](../../../imgs/prog_paradigm_lang4.png)

- 一种编程范式之所以能独树一帜，__关键__ 在于它 __突破__ 了原有的编程方式的某些限制，带来革命性的新思维和新方法，进一步解放了程序员的劳动力，这便是范式的核心价值所在

## 情景范式
可以这么理解 __闭包__：所谓包，指函数与其周围的环境变量捆绑打包；所谓闭，指这些变量是封闭的，只能为该函数所专用





抽象封装
==========

## 抽象思维
无论是编程范式风格上的差异，还是编程语言级别上的高低，皆源于各自提供的 __抽象机制__ 的不同

抽象就是做 __减法__(去粗取精)和 __除法__(异中求同，同类并归[乘法为同类复制])

抽象有 __角度__ 之分，相同的实体经过不同角度的抽象，得到的模型会不同

分析与设计：

- 分析(理解问题领域，明确业务需求，制定出功能规范/非功能规范)；设计(制定出实现规范)；实现(完成编码)
- 分析阶段多采用 __性质导向式__ 抽象(定性，关注是什么what，而不是怎么样how)；设计阶段多采用 __模型导向式__ 抽象(定量)，通过构造数据模型来满足系统的性质，实现功能规范
- 分析阶段前期(领域分析)只 __标识类的性质__(属性和关联)，类的运算可有可无；分析阶段后期(应用分析)个体类的运算不如 __整体系统的动态行为__(用例图/活动图)重要；到设计阶段，__个体类运算__ 才是关注点之一

抽象机制：

- 参数抽象：函数的每一个参数都是一种泛化，是对它所代表所有可能值的一种抽象
- 规范抽象：通过规范使代码的功能与实现相分离，规范了服务提供方的义务，保障了服务享受方的权利

子类的先验条件可以弱化(接受更泛的参数)，后验条件可以强化(返回更细的返回值)，但不能反之

契约式设计的语言Eiffel/D，明确保障包括先验条件，后验条件，类不变量，副作用等在内的契约，语言引用assert就是为了支持契约式编程

五类基本抽象：

- 过程抽象：自定义运算的能力 将行为的逻辑属性与实现细节分离
- 数据抽象：自定义类型的能力 将数据的逻辑属性与表现细节分离
- 迭代抽象：自定义循环的能力 将集合遍历与元素的获取细节分离
- 类型层次：自定义类族的能力 将类型的公共行为与具体类型分离
- 多态抽象：自定义多态类型的能力 a抽象类型(类型的接口规范与实现代码分离)；b参数类型[泛型](将类型与算法分离)

## 数据抽象

数据结构强调具体实现，多从实现者和维护者角度来考虑；抽象数据类型(ADT)强调抽象接口，多从设计者和使用者的角度来考虑

参数抽象使数据接口普适化，规范抽象使数据接口契约化

接口与实现分离，有利于开发时间的分离及开发人员的分离

C中以static函数表示内部函数

以接口为中心，强调对象行为，对象交互，属于OOD；以数据为中心，强调算法对数据的依赖，属于OOP；OOA则是描述问题，而非解决问题

可以将类理解为具有继承与多态的ADT

##　封装隐藏
信息隐藏是一种原则，封装是实现这种原则的一种方式

反射机制多用于单元测试、代码分析、框架设计等，常规应用很少使用

封装，不能直接返回类的内部对象(可变域对象mutable field object)，用户调用方法后可直接进行操作，破坏了封装，C++中可使用const成员函数，其它语言考虑返回复制品

在设计类时，必须考虑在语义上是引用对象还是值对象：

- 值对象关心的是值，而非它的同一性，不希望不同的对象因共享相同的引用而导致同步修改，如果值对象是可变的，往往需要利用值拷贝防止因同一性而导致意外同步变化
- 引用对象重要的是同一性，而非值，不须要也不应该进行值拷贝

信息隐藏中的信息不仅仅是数据结构，还包括实现方式和策略

抽象接口
==========

## 软件应变
软件变化

- 出于内在需求而作的结构性变化，以改善软件质量为目的，包括重构、性能调优等
- 出于外在需求而作的功能性变化，以满足客户需求为目的

## 访问控制
友函数常用于运算符重载

一个类与其友类或友函数是联合关系而非主客关系，它们之间的互访与普通类内部成员互访没有本质的不同，甚至由于friend是单向授权的，反而是private的一种细化

一个类的方法能访问除this之外的其它同类对象的private成员，盖因访问控制是对静态代码的控制，而不是动态对象，以代码而非对象为边界

## 接口服务
提供的服务过多则不纯粹，过少则不完备

讲究服务的一致性与关联性

继承机制
============

## 继承关系
继承强调的是语言机制，子类继承父类；泛化强调的是概念关系，强调设计，父类后于子类提炼共同特性而设计的，称为超类

从子类到超类的泛化是概念抽象的过程，从超类到子类的特化是概念细化的过程，两种设计手法经常交替使用，属于上述五种基本抽象中的类型层级

java和C#只能继承接口，或既继承接口或继承实现，不能只继承实现

C++则可以做到，即private继承

但java或C#中可通过组合的方式而非继承的方式来达到对实现的重用

所以C++中的非公有继承可以看成匿名的非显性合成，只不过前者更具侵入性(可访问基类成员，重写方法)，后者更隐蔽与动态性(可被替换)

接口继承的作用不是为了让继承者重用，而是为了在合适的场合被调用，即不是为了代码重用，而是为了代码 被 重用

子类型不是子类(如int是long子类型，但不是它的子类)，子类也不一定是子类型(C++中private继承)，子类型关键是可代换性，即里氏代换(LSP)

接口继承必须建立在LSP之上，接口重用达到规范重用

多态抽象指一种类型可能具备多种类型的形式

如果只是为了重用基类的代码(权利)，而不希望重用它的接口(义务)，应该采用合成而不是继承方式

通用编程原则，尽可能弥合语法与语义之间的缝隙，以压缩代码臭虫的空间

继承与其说是is a的关系不如说behaves like，正如正方形是矩形，但行为并不一样，所以并不是继承关系

任何类型都应该保持或强化其超类型的规范，绝不能弱化规范

子类型 要求更少(接受更泛参数)，承诺更多(返回更细类型,协变返回类型)

JDK败笔 Properties继承Hashtable，Stack继承Vector


类偏重语法,强调实现方式，类型偏重语义，强调行为方式

OOP将现实中的概念抽象映射为程序中的类型，继承机制进一步将概念的分类体系映射为类型的层级结构


## 慎用继承

继承是一种静态(编译时建立)、显性关系(公开的)

描述了java与C#在对待重写时的区别


多态机制
=========

## 多态类型
GP中参数多态 OOP中子类型多态

前者让相同的实现代码应用于不同场合，后者让不同的实现代码应用于相同的场合

前者看重算法的普适性，后者看重接口与实现的分离度

都是在保证必要的类型安全的前提下，突破编译期间过于严苛的类型限制，保证代码灵活性、可维护性和可重用性

模板方法突出稳定坚固的骨架，策略模式突出是灵活多变的手腕

## 抽象类型
抽象数据类型的核心是数据抽象，抽象类型的核心是多态抽象

先以术养道，后以道御术

具体类型是创建对象的模板，抽象类型是创建类型的模块

一个是为对象服务的，一个是为类型服务的(它的抽象性正源于其服务的抽象性)

接口继承不是为了重用，而是为了被重用


值与引用
=========

## 语法类型
C++没用引用类型，但有&引用和*指针，具有引用功能，属于 引用端 的引用，而C#/java中引用类型是指 被引用端 的

语言中内存分配机制(按灵活递增)静态分配、栈分配、堆分配:

- 静态分配发生在编译期，为全局变量、静态变量、常数变量等安排空间
- 栈分配和堆分配均发生在运行期，但前者一般在编译期就可确定待分配内存的空间大小和生命周期(例外，C的alloca允许程序员在栈上分配动态大小的内存，但由编译器释放)
- 栈内存区主要用于存储局部变量或自动变量
- 堆内存区用于存储new运算符、malloc函数等动态分配而得的空间

栈分配效率高，通常每个线程都有独立的栈区，故栈变量天然是线程安全的，栈分配主要缺点须预知分配内存，而且栈区总容量有量，容易发生溢出。

堆分配更强大，更灵活，但复杂的算法影响了时间效率，内存碎片、元数据开销和可能的内存泄露等问题也影响了空间效率，此外程序员还需要担负更多的内存管理、线程安全等方面的责任。

一个C#/java的方法中

<!--language: csharp-->

    someType a=new someType();//someType为class

则a是局部变量分配在栈中，a指向的对象分配在堆中，a出了作用域就被编译器回收，而它指向的对象则被GC回收


C++中

<!--language: cpp-->

    someType* a=new someType();//分配在堆上  同java相似，只是多了*
    someType a=someType();//分配在栈上 或 someType a;

同C#的值类型相似，只是少了new

java中

<!--language: java-->

    class TestPassByRef{
      static void change(String str){str="new value";}
      public static void main(String[] args){
        String s="Old";
        change(s);
        System.out.println(s);
      }
    }

change的实际参数s是一个string引用，而不是string对象，让变量s换指另一个对象，并不能改变它当前所指对象

java按值传递对象的引用，并不支持按引用传递，因为所有对象都是引用类型，对象本身并不会被复制

C++的引用传递

<!--language: cpp-->

    void change(String& s)//传递对象的引用

C#的引用传递

<!--language: csharp-->

    void change(ref string s)//传进对象引用的引用

当一个对象给一个变量赋值或作为参数按值传递时，在C++中复制的是该对象的值，而java中复制的却是该对象的引用，因此，C++有专门的赋值运算符和复制构造函数，而java没有，java要达到复制对象值的目的，不能隐式的通过变量赋值或参数传递，只能显式的重新构造对象或clone/serilaization

java的按值传递无法解决：改变引用变量的目标对象，改变基本类型的值，将两个参数互换，同时返回多个计算值

以上只是语法，而语义才是设计者需要考虑的


<!--language: cpp-->

    //让值类型具有引用语义
    ValueType v1=someValue;
    ValueType& v2=v1;
    ValueType* v3=&v1;

    //让引用类型具有值语义
    ReferenceType r1=someObject;
    ReferenceType r2=(ReferenceType)r1.clone();

值语义变量的内存地址无关紧要，又称复制语义

引用语义变量的内存地址至关重要，通常用指针来实现，又称指针语义

OOP三在特性是：状态、行为、标识

没有标识的对象，则具有值语义

值语义一般地址无关性，时间无关性，通常是不可变的(immutable)

不可变为引用类型表示值语义提供是变通的语法支持 如java中的String/Integer/Boolean

C++中string是值类型的，但不是不可变的，但可以使用const来保证

值类型有时需要以引用类型的身份出现，就是装箱

不可变性加强了值语义

引用语义对象的改变是一种自我更新，值语义对象的改变是一种新旧更替

值语义的复件具有等效性，而引用语义的复件不具等效性

UML建模中，值对象多用于属性，引用对象多用于关联，值对象是附属的，被动的，引用对象是独立的，能动的

合成是基于值语义的包含，聚合是基于引用语义的包含


设计原则
=========

## 间接原则

任何计算机问题均可通过增加一个间接层来解决

像文件路径、URI、外键都具有间接指代作用

抽象层应当具有间接性

间接层也应当为抽象性，它应当是一个标准，标准是一系列规范的集合，而规范为显化的抽象

一个适当的中间层，在形式上表现为间接层，在实质上体现为抽象层

## 依赖原则

## 内聚原则
C/C++中静态全局变量只能在定义它的文件中被访问

接口隔离原则(ISP)主张，不应强迫客户依赖那些它们不用的方法

## 保变原则

设计模式
=============
## 创建模式
工厂方法，使用模板方法，子类重写各部件的创建，逻辑存在基类中

抽象工厂，如果把创建组件当成一种策略，接口中包括一系列多个产品的创建，可视为策略模式的应用，

APP使用接口，常使用依赖注入来获取工厂对象，逻辑存在APP中

创建者模式分离了对象的创建与对象的结构表示(无须一个抽象类型来表示产品)，故能做到工厂模式难以做到的事

接口中包含创建步骤，均返回void(导致用户无须知道各部件类型)，最后一步产品创建成功

工厂保护变化是产品制作的来源，创建者保护的变化是产品的制作细节

## 结构模式
抽象是前提，分解是方式，模块化是结果

层是按抽象层次进行的水平划分

不提倡向下转型，盖因把高抽象的类型转化为低抽象的类型，破坏了抽象层次的一致性

桥接模式的重点是分解，让本来结合紧密的接口与实现分离开，适配器模式重点是结合，让本来无关的类能合作共事

装饰者模式具有类型层级和聚合层级有交合的地方

适配器改变对象的接口而保持对象的职责，装饰者改变对象的职责而保持对象的接口

代理模式

C++中智能指针对java/C#意义：保证互拆(同步代理)、引用计数(计数代理)、写时拷贝或迟拷贝、延迟加载

值语义的对象适合享元模式

## 行为模式
OOP弱点，一个对象必须在获得另一个对象标识后方能向其发送消息
而Prolog或声明式编程无须如此，如shell中管道 `cat<file1|sort|uniq|comm -12 - file2>common`

职责链关心是职责的分解，更侧重行为

装饰者关心是职责的结合，更侧重结构

命令模式，请求的发送者与接收者在空间和时间上解耦
























