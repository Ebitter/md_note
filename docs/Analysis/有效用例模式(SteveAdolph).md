> 2014-09-06

<!-- 
ActorIntentAccomplished
Adornments
BalancedTeam
BreadthBeforeDepth
CapuredAbstraction
CleanHouse
ClearCastOfCharacters
CommonSubBehavior
CompleteSingleGoal
DetectableConditions
EverUnfoldingStory
ExhaustiveAlternatives
ForwardProgress
InterruptsAsExtensions
LeveledSteps
MergeDroplets
MultipleForms
ParticipatingAudience
PreciseAndReadable
PromotedAlternative
QuittingTime
RedistributeTheWealth
ScenarioPlusFragments
SharedClearVision
SmallWritingTeam
SpiralDevelopment
TechnologyNeutral
TwoTierReview
UserValuedTransactions
VerbPhraseName
VisibleBoundary
WritersLicense



 -->



概述
========
早些年，没有人能清楚说出一个用例与场景的区别，但那些想法却保留了下来：书写短小的、基于文本、关于系统如何与周围事物交互的叙述，这些交互为用提供一个价值，同时捕获出现错误时的系统行为

在形成不同流派中，几乎是下列问题的排列组合

- 一个用例是一项需求还是只是一个故事？
- 场景是否只是用例的另一个名字？（Martin Fowler认为是）
- 用例的结构是形式的、非形式的、还是半形式的？
- 用例是否有关联结构，还只是堆在一起？

我们选择是一条中间路线，半形式的结构中的半形式文本：

- 断言用例确实是需求并且需要一个基本结构，同时，
- 允许人们在需要的时候书写任何想写的东西（更重要）

## 使用目标组织用例
用例描述了一个参与者试图使用系统达到一个目标，将 __*注意力*__ 从功能列表转移到 __*用户身上*__ ：用户真正需要使用这个软件来完成什么是他们使用这个软件的目标，如果软件支持这些目标，软件将产生最大的商业 __*价值*__

目标有时会失败，__*思考*__ 并写出需求文档中 __*失败处理*__，能够在项目过程中为设计团队节省 __*成本*__

因此一个用例的结构分为两部分，每件事都顺利进行时事件序列，随后是各个目标和子目标失败时的不同小事件序列的描述

甚至可以说，用例的最大价值不在于主场景，而在于备选行为

## 加入涉众和利益
为什么我们要在用例中书写外部不可见的行为？如在给钱之前记录“银行检查客户余额”

计算机的动作 __加强了 *涉众之间* 的契约__，每一个动作既是为了维护这个涉众的利益，也是为了维护其他涉众的利益

Jim走向糖果机，他的目的不是花钱，真实目的是想吃糖，如果糖是免费的，他会更高兴。糖果机的主人立场相反，他的目的不是为了发放糖果，如果人们只往机器放钱而不要糖，他也会更高兴。糖果机加强了一个简单的契约：Jim放入钱，机器的主要看着他得到糖果

在保险业务的相关契约中更加复杂：受益人提出索赔；保险公司在允许的范围内付出最少金钱；保险部门检查事务的操作在政策之内。

__涉众和利益模型__ 填补了 __参与者和目标模型__ 的空白。系统接受消息，根据业务规则验证输入值，更新内部状态或输出数据，它的每一个动作和涉众利益相关，主参与者和辅助参与者都照顾到了

## 反对用例的声音
这些人认为用例是非形式、非结构化，不是需求，而通过：特征列表（feature lists）、故事卡片（story cards）、task cases等技术

## 用例的局限
用例不关心系统设计、界面设计、特性列表或测试，即使许多人想这么做

高质量的用例
===========
## 为什么要使用用例
- 首先，用例提供了一种基于构建故事的半形式化框架，参与者和用例，以及它们间的通信规则，不足以讲述一个故事，故事必须有一个目的。用Ivar Jscobson的话说，“为系统内的单个参与者产生一个有可度量价值的结果”
- 其次，在每个用例和所有描述层次中，用例都描述了错误情况的系统需求
- 再次，虽然用例本质上是一种功能分解技术，但它们已经成为面向对象软件开发的一个流行元素
- 最后，用例提供了可以在其上处理其他项目信息的骨架：
    - 项目经理可以根据用例进行估计和发布进度；
    - 数据及业务规则制定人员可以把自己的需求和所需用例联系起来；
    - 界面设计人员可以进行设计，并将其与相关用例联系起来；
    - 测试人员可以根据用例中描述的成功和失败情况构建测试场景。

## 讲述好故事的困难
- 用户界面细节太多，通常发现对鼠标点击、列表框和窗口设计的引用，用户界面设计细节通常不是需求，它们一般是设计选择，在编写并评审了用例之后，才需要做出设计选择，`Adornments`模式和`TechnologyNeutral`模式阐述如何避免过多的细节
- 较低目标层次上的用例太多，程序员经常会在“验证用户身份”这类层次上生成大量低层次用例，很大程度是因为这些功能必须实现，但这样编写的需求文档就很长，难以阅读，也无法展示系统给最终用户和客户提供什么功能。`CompleteSingleGoal`模式讲述了如何适当地构建用例，避免这类问题
- 使用用例表示非行为信息。其实用例只适用于描述行为，有些人员用非常详细的用例描述用户界面表单的完成。最好是创建一个`Adornment`，将性能需求、复杂的业务规则、数据结构等放入
- 太冗长，较好的用例通常为3~9步，`LeveledSteps`模式讲述如何编写均衡、大小适度的用例
- 目标实现不完整，编写人员没有捕获目标实现的全部行为，而只是描述了所必需行为的一个片断。由于用例间没有联系，程序员只能猜测如何将它们连在一起，没有考虑所有故障情况或可选行为。`CompleteSingleGoal`模式和`ExhaustiveAlternatives`模式就如何把目标和用例联系起来，以及如何包括所有必须的失败情况给出了建议
- 句子片断，一个相对较小但也要注意的错误是不要用句子片断编写用例。如果在操作步骤中省略了参与者名称，就很容易导致项目过程混乱。`ActorIntentAccomplished`模式讲述了如何编写步骤清晰且无二义性的场景

## 一个示例
> 登记课程
> 
> 1. 学生请求提供一张新课程表
> 
> 2. 系统准备好空白的课程表表格，从“课程分类系统”中抽取已开设和可选的课程列表
> 
> 3. 学生从系统提供的上述课程中选择主修课程和选修课程
> 
> 4. 对选中的每门课程，系统确认学生已学习了必需要前导课程，然后把学生添加至该课程中，并在课程表中标记学生“已登记”该课程
> 
> 5. 学生说明课程已填好之后，系统保存课程表

## 用例模式表格
- __模式名称__
    + 强调所建议解决方案的共性的名词短语。
    + 如`UserValuedTransactions`这个名称让人觉得该服务是对某个人是有价值的
- __一张图片__
    + 为模式提供一个形象的比喻。
    + 如`UserValuedTransactions`的形象比喻是排队准备为赛马下注的人，他们愿意排队付款，说明他们认为这一行动是值得的
- __上下文__
    + 问题发生的条件，描述了限制模式和解决方案适用场合的边界，还描述了该模式如何与语言中其他模式相关，并指出了哪些模式是该模式的先决条件。
    + 如`UserValuedTransactions`的上下文是：已经建立了项目的`SharedClearVision`，并定义了需要系统提供服务的`ClearCastOfCharacters`
- __问题陈述__
    + 由一两个句子组成，这些句子描述了当用例不能满足一定的标准时会发生什么情况，这些陈述还反映了 __不遵照该标准带来的风险__。
    + 如`UserValuedTransactions`的问题陈述为：如果系统不能对用户提供有价值的服务，并且不支持系统愿意规定的目的和目标，那么，该系统就是不完善的
- __隐喻故事__
    + 提供隐喻故事，以使模式更易于理解
- __影响问题的约束__
    + 概述了影响问题的各种因素，以及在使解决方案复杂化和约束解决方案的各种因素之间的权衡，这部分描述了编写者必须对所面对的具体情况作出重要权衡
    + 如`UserValuedTransactions`，我们需要平衡的约束：
        * 一组用例应该捕获用户和涉众需要系统提供的基本增值服务
        * 识别低层事务相对较为容易，但识别有用的服务可能就难了
        * 用例需要相对稳定，因为它们形成了产品开发过程其他部分的“定位点”
        * 读者希望容易看到系统如何满足其目标（请看`SharedClearVision`）
        * 人们有一种太高或太低的层次上工作的倾向
- __解决方案__
    + 该解决方案是平衡了相互竞争的约束，并反映了编写良好的用例的特征
    + 如`UserValuedTransactions`的基本解决方案是：识别系统为参与者提供以满足其业务目的的有价值服务
- __示例__
    + 每个模式都有一个或多个示例，证明实现模式所建议的解决方案的好处，或不这样做的后果

## 模式语言的组织
31个模式分两大类：开发模式和结构模式

### 开发模式
描述了已经过验证的用例编写实践的特征，并提供了度量编写过程质量的准测

- __团队组织__：判断和改进用例团队组织方式的质量的模式
    + 团队的人员的变化是一个重要但经常被忽视的方面。在对所得到用例的影响方面，编写人员之间的个人交互与用于识别编写用例的技术造成的影响不相上下
    + 编写`PreciseAndReadable`用例要求有一个`BalancedTeam`和一个`ParticipatingAudience`。赞助者、开发人员、交互专家和领域专家都参与这项工作并对它进行评审。然而编写人员太多反而会把问题搞砸，任何一个编写任务都应该使用一个`SmallWritingTeam`
- __过程__：判断和改进团队用来创建用例的方法质量的模式
    + 遵循一个好的过程对于编写高质量的用例非常关键，该过程不一定很讲究或很强大，但一定要包括所有基本成分。好的过程意味着平衡发现和编写，用足够内容对系统进行充分描述，不返工，不做多余工作，以使开发人员能够开始构建系统
    + 尽管不提倡创建用例的任何具体过程，但高效的团队都使用`BreadthBeforeDepth`，部分扩展一些用例之前，首先命名许多用例，在考虑失败处理之前完成主成功场景，并实现用例集的`SpiralDevelopment`
    + `SmallWritingTeam`将它的工作与`TwoTierReview`集成在一起，其中，具有不同专长的核心工作人员先对工作进行评审和调整，然后才将其交给包括有涉众代表的团队
    + 有效的团队知道什么时候是`QuittingTime`，团队成员不会长时间争论一个肤浅的问题，而是允许一定数量的`WritersLicense`，他们认识到强迫所有人员使用一致的编写习惯或不太得要的标准很快就会使这项工作不再增加价值
    + 并不是每个项目团队都需要相同数量的细节来完成其任务，用例的`MultipleForms`是需要的，也可将每个格式用到同一个项目的不同时段上
- __编辑__：随着潜在需求的变化和编写人员知识的增加，判断和改进单个用例质量的模式
    + 因为潜在的需求非常不稳定且容易发生变化，因此，用例可能很快就会过时，随着对系统深入理解，它会发生变化，通过调查与客户交谈，可以加深对系统的了解。
    + 在编写过程中，组员会定期发现他们编写的用例要么大而复杂、难以阅读，要么小、不重要。应该将大的用例`RedistributeTheWealth`分成较小的用例，并太小的用例`MergeDroplets`合并到其他用例中。最终，他们可能会发现一些用例完全无关的，为了处理这些用例，可以`CleanHouse`

### 结构模式
描述了用例的基本组成部分，解释了应该如何对其进行组织，并提供了判断其使用的准测

- __用例集__：判断和改进用例集质量的模式
    + 用例集是用例和相关信息的集合，它以一种便于使用的方式组织为用例模型，包括产品的系统级信息，包括参与者、边界以及成员用例之间的关系，这一级别主要是组织级的，描述是集合的关键特性而非具体行为。在这一级别工作的人们通常根据名字引用单个用例，忽视它们的内容
    + 用例集最重要事情是，应该清晰的`VisibleBoundary`来反映系统的`SharedClearVision`。用例共同组织为较高层的用例，这些高层用例从`EverUnfoldingStory`中引用低层用例，`EverUnfoldingStory`则展示了`ClearCastOfCharacters`，它们与系统交互来实现它们的目标。尽管在各个级别上都有描述的目标，但最关键和有兴趣的目标描述的是`UserValuedTransactions`。
- __用例__：判断和改进单个用例质量的模式
    + 单个用例描述对`CompleteSingleGoal`的追求，它应该有一个描述性的`VerbPhraseName`来让读者了解它的意图，每个用例都对可以实现它的多种方式，成功的、不成功的，用一个描述在不同条件下将会发生什么情况的场景片断集合，组织成`ScenarioPlusFragments`，一个完整的用例考虑`ExhaustiveAlternatives`
    + 为了使赞助者、用户和开发人员满意，编写人员要力争使用例`PreciseAndReadable`，这是用例编写的一种技巧，同时也是一种可实现的目标，从用例文本中消除性能需求、数据格式以及用户界面，用文档分离它们，作为`Adornments`
- __场景和步骤__：判断和改进用例场景以及这些场景中的步骤质量的模式
    + 场景描述了用例中一个完整的事件序列。主成功场景后的每个场景片断都描述了参与者在某些`DetectableConditions`下的行为（对讨论中的系统来说是可检测的）。良好用例的可读性部分是`LeveledSteps`，它使所有的步骤都保持在大致相同的详细级别上
    + 每个步骤都应该使不同的`ForwardProgress`靠近目标。由于用户界面细节和其他设计决策作为`Adornments`出现的，因此能够用`TechnologyNeutral`方式详尽编写每一个步骤，最后，每一个步骤都应该使`ActorIntentAccomplished`，读者总能说出谁在做什么
- __用例关系__：判断和改进集合中用例之间的结构关系质量的模式
    + Ivar Jscobson定义了 __“包含”、“泛化”、“扩展”__ 的概念
    + 当一组共有的动作在几个用例中再次出现时，最简单和最自然的联系就是把`CommonSubBehavior`移到由其他用例通过“包含”关系引用的子用例中。
    + 当单个事件可能多次中断用例流时，编写人员就应该把那些中断编成扩展（`InterruptsAsExtensions`）
    + 如果一个给定的分支开始支配用例，那么，应该考虑把分支提升为扩展用例，即`PromotedAlternative`
    + `CapuredAbstraction`建议何时使用泛化


团队
======
## 团队的组织问题
每个用例编写团队都应该是一个`SmallWritingTeam`，其中，任何用例的编写人员数量都应该限制为2或3人，以避免低效或由团体设计用例

在保持用例编写组织规模较小的同时，还应让尽可能多的涉众参与编写过程，以确保用例满足所有涉众的需要，`ParticipatingAudience`解决了管理团队规模中相互冲突的问题

团队的构成是影响用例质量的另一个因素，有效的团队是`BalancedTeam`，由具有不同技能、专业知识甚至个性的人组成的

## SmallWritingTeam
有一个系统的`SharedClearVision`，正在组织人员来编写用例。

用太多的人编写用例是低效的，为了统一不同的观点所做的折衷可能会导致开发出来的系统不太令人满意

- 用例要求具有不同观点和专业知识的人编写
- 将大组人聚集在一起是困难的
- 理论上，在用例上投入的人力越从，就能越快的完成用例编写工作，但超出了足够人员时，事情会变糟
- 太大的团队会变得低效
- 大型编写团队可能会通过集体讨论的形式开发用例，添加许多不必要的特性

__因此，__ 将精化任何一项制品的人员数量限制为2或3个，使用`TwoTierReview`过程包括更多的参与人员

同时，尽量表现每个小组的不同观点，创建`BalancedTeam`，选用具有不同背景、技能和个性的人员，以使团队不会用相同的方法看待用例

使用`ParticipatingAudience`和`TwoTierReview`使更多的人参与到过程中，提高人的参与程度，同时避免使用大型编写团队

## ParticipatingAudience
正在创建用例的一个`SmallWritingTeam`，没能涉众提供信息和反馈，就不能满足他们的需要

- 许多不同的小组对同一组用例有着不同的兴趣
- 如果客户不喜欢开发出来的产品，他们就不会购买
- 在用例开发过程中包括所有目标读者通常是不切实际的
- 开发组织并不能充分代表最终用户

__因此，__ 尽可能使客户和内部涉众积极参与用例开发过程

可通过评审很好的与客户共享用例，充分利用客户时间，组织良好的`TwoTierReview`更是如此，通过评审与那些平时无法接近的客户和用户交流

## BalancedTeam
正在组织`SmallWritingTeam`来编写用例，由一些个性相似、意见相同的个人组成的团队开发用例，可能会得到一组缺乏创见、范围狭窄的用例，这种用例不能满足每个人的需要

- 由技术背景相同的人员组成的小组很可能会把注意力放在相同的、狭窄的问题上
- 每个专业都使用其专用词汇，该专业以外的人不能理解这些词汇
- 在不同的时期，开发团队需要不同的专业知识
- 出色的小组是平衡的，这样，每个人的专长都可以弥补其他人的弱点

__因此，__ 为小组配备具有不同专长的人员，以维护开发过程中涉众的利益，确保团队中包括开发人员和最终用户

过程
=======
尽管没有创建用例的通用过程，但还是有一些通用元素，这些模式并不构成一个过程，它们之间没有一定的顺序，而是陈述一些有关过程的事实。

一个有效的过程以一种`BreadthBeforeDepth`的方式创建用例，在对其进行描述前识别潜在的用例，以一种可控的方式添加细节，并实现用例集的`SpiralDevelopment`，在开发用例时，人们所犯一个最大错误就是按顺序编写，容易耽搁在难以开发的用例上，或在随后用例开发中发现需要重新编写已完成的用例

一个有效的过程能够使编写人员从`MultipleForms`中进行选择，并确定适当的详细级别

传统评审过程通常是低效的，他们可以要求一个大的、由具有相互竞争需要的评审人员组成的多样性小组。为了避开这一问题，`TwoTierReview`描述了如何进行评审，描述了内部评审和紧接其后的外部评审，对于那些趋于完整的用例，在将其提交给更大的小组来从系统的角度对其进行评审前，要先对它们进行正确性和完整性评审

有效的团队知道什么时候是`QuittingTime`，他们不会在不太重要的问题上争论不休，而是允许一定数量的`WritersLicense`，他们认识到强迫所有人员使用一致的编写习惯或不太得要的标准很快就会使这项工作不再增加价值

## BreadthBeforeDepth
已经有了`SharedClearVision`和`ClearCastOfCharacters`，并开始编写有例，如果浪费精力按顺序编写详细用例，就不会及时取得进展或创建一致的用例集

- 需求收集是一个发现的过程
- 人们很早就开始编写用例的细节
- 人们浪费了精力或陷入了太多的细节中
- 在早期获得概述是有益的
- 最初编写的细节越多，在了解系统后必须进行的改变也就越多

__因此，__ 通过首先开发用例的概述来保存精力，然后逐步增加细节，并行开发一组相关用例

开始编写用例时，在添加细节前先对其进行概述，通过为每个参与者关联一个有意义的目标来识别候选的用例，为每个参与者－目标组合定义一个用例（`UserValuedTransactions`）。使用目标为每个用例导出一个`VerbPhraseName`。一旦觉得已经定义了一个 __相当完整的用例集__，就开发这一组用例，对其进行精化，将等效的用例组合在一起，并消除不必要的用例(`RedistributeTheWealth`，`MergeDroplets`，`CleanHouse`)。所得到的系统目标集合为涉众提供了基本的、共有的理解，并帮助减少了后来需要的重构工作

避免突然开发完所有用例或一次只开发一个用例的倾向，要以一系列`SpiralDevelopment`周期的形式开发用例，渐进地添加细节，评审新细节对模型的影响，直到确定已到了`QuittingTime`

通过描述每个用例的主成功场景，指定可能发生的各种情况，充实一些更重要的用例，将用例扩展为`ScenarioPlusFragments`。从集合中消除不重要部分时要果断，向片断中添加更多的细节时，在下一个周期中创建一个`ExhaustiveAlternatives`

当进行渐进开发时，模坂可以作为能够使编写人员在遗漏大段内容的情况下编写用例的占位符。使用`MultipleForms`，将适当的详细级别和精度将每个用例编成文档

有时，确实也需要为用例划分优先级

## SpiralDevelopment
正在用`BreadthBeforeDepth`方式编写用例，用“一次通过”的方式开发用例是困难的，并且会将新增信息集成到用例中变得昂贵。更糟糕的是，它可能会拖延发现风险因素的时间

如果发现用例并没有带来预期的结果，我们可以轻松地回去，抛弃它们或者重新编写。使用迭代的方法可以使我们更快地识别和面对潜在的问题

- 理解系统的行为可能会花掉的时间
- 拖延是昂贵的，需要尽快的完成用例的编写
- 对需要进行分析后，需求很可能会发生变化（分析需求就很可能会改变需求）
- 需求错误的成本是昂贵的
- 如果工作进展得太快，就会使人感到不堪重负

__因此，__ 用一种迭代的、宽度优先的方式开发用例，每次迭代都会逐渐提高用例集的准确性和精度

按照`BreadthBeforeDepth`的模式，当列出了参与者和它们的目标时暂停一下，暂时使用该列表进行其他工作：制定项目计划，对工作进行估计并划分用例价值的优先级，甚至使用它帮助组建开发团队

继续按`BreadthBeforeDepth`的模式开发用例，选择用例的一个工作子集进行扩展，当有了一组主成功场景后再次暂停一下，评审系统的目的。此时，抓住机会对用例进行评审。看看是否需要`MergeDroplets`或`CleanHouse`，或用任何其他方式改进结构，可能会发现自己修改了参与者和目标的列表

当开始找出用例的扩展处理时，可能会发现自己再一次修改了用例列表，通常会出现新用例

`SpiralDevelopment`与`BreadthBeforeDepth`交互，`SpiralDevelopment`建议编写团队暂停并重新对用例分组

成功使用迭代开发的关键是，知道如何控制在评审中投入的精力，以及在什么时候应该停下来，使用`TwoTierReview`，并在只要自己确信用例已足够好，能够满足涉众的需要时就停下来

示例，首先从简单的东西开始，仅列举参与者以及他们使用的用例名称，一旦编写人员完成了列表，可以尝试编写简单的，仅有一个段落的故事，来描述用例的主成功场景，通常被称为“概要”或“高层用例”

> 预约航班
> 
> 参与者：代理人
> 
> 代理人详细说明客户要求的旅行路线，系统搜索合适的飞行路线并将其提供给代理人。代理人选择一个最佳满足客户要求的路线。系统验证有座位，然后预约座位。系统计算代理人所请求的服务类别的机票价格

__摘要并不叙述详细的步骤、分支、前置条件和后置条件，相反，它们的目的是在深入讨论细节之前，快速包含系统的主要范围－宽度__

## MultipleForms
正在使用`SharedClearVision`，不同项目需要不同程度的形式化，每个人对模板都有不同的偏好，要求每个人都使用相同的用例模板只会起到相反作用

- 人和项目都是不同的，每个人都是独一无二的，都有自己看待问题的方式
- 不同的项目有不同的需要，可大可小，可简单可复杂
- 不同的编写团队需要不同程度的规范
- 在组织中使用公共的编写形式有助于交流

尽管模板有用，但一口气填充完所有的模板，可能会耗尽精力，并失去重点

__因此，__ 根据与项目相关的风险以及所涉及人员的偏好选择用例编写格式

选择用例格式时，要能接受新思想，不要陷入所有用例看起来都应该相同的惯例中，根据用例目的以及与每个用例相关的风险级别选择模板，对于关键用例，编写包含大量丰富信息的更加形式化的用例，并密切关注`ExhaustiveAlternatives`和`PreciseAndReadable`，对于不太关键或理解较好的用例，不要太形式化并使用较少的细节

对于一个编写小组来说，很难使用多个模板完成用例的编写，应选择一个标准的模板，然后一直使用下去，该模板有助于编写团队处理用例集的`SpiralDevelopment`

## TwoTierReview
正在用一系列的`SpiralDevelopment`编写用例，许多人可能需要评审用例，这是一件昂贵耗时的事情

- 对于验证和确认编写及内容来说，评审是必要的
- 涉众在用例中有一种既得利益
- 使每个人参与编写过程非常昂贵、麻烦并且缓慢
- 如果仅由一个小的编写组进行评审，就不会考虑所有涉众利益
- 评审可能是昂贵、乏味和耗时的

__因此，__ 进行两种类型的评审：第一种由较小的内部小组进行的评审，可能重复进行很多次；第二种是由整个团队进行的评审，可能只进行一次

内部评审，以验证其可读性、实现性、精度和准确性，可以是非正式的集体评审，当系统过大或复杂时，可能需要进行几次这样的内部评审

内部评审结束后，小组提出`QuittingTime`，认为用例是完整、正确的，达到应该达到的可实现性，然后，更大的团队将检查这些用例

外部评审的目的：

- 这真的是开发人员要花时间构建的适当产品吗？（业务价值检查）
- 这作为规格说明正确吗？（业务规则正确吗？它是否为实现预留了允许的适当变化？它是否遗漏了重要的决策？它是否识别了可在以后处理的适当的保留问题集？）
- 开发人员真的能够构建吗？

## QuittingTime
用`BreadthBeforeDepth`方式编写了一组用例，开发一个超出了涉众和开发人员需要的用例模型不仅浪费资源，而且会拖延项目进度

知道什么时候停止编写用例可能是困难的，因为确定什么时候停止涉及到一些复杂因素的平衡

- 忽视重要需求的巨大恐惧使构建人员和涉众延长了需求收集活动
- 许多技术专业人员给了模型的形式一个没有根据的高优先级
- 模糊可以对项目造成破坏
- 大多数人都可以用一种合理模糊性工作
- 对需求的过多说明可能会使涉众相信需求的表述非常精确
- 如果及早发现错误，其成本还是很低的，但停止不前的成本通常是很高的

__因此，__ 在用例完整并且符合参与者的需要后，停止开发用例

为了确定用例是否已经完整：

- 是否识别了所有的参与者和目标并将其编成了文档？
- 客户或代表客户的其他人是否承认用例集是完整的，而且每个用例都是可读的和正确的？
- 设计人员能够实现这些用例吗？

不要太担心质量，要避免过多关注表面上的东西，超过临界值后，进一步开发用例不会增加对系统的任何理解

## WritersLicense
正在对用例进行`TwoTierReview`，并且怀疑是否到了`QuittingTime`，过分强调格式问题不必要的阻止了编写用例的工作

- 我们喜欢一个一致的编写格式，以简化阅读
- 让每个人都用完全相同的格式编写用例不仅代价很高，而且不切实际
- __尽早使用例进入开发阶段是有价值的__
- 仍然需要满足用例的基本完成准则：可读、逻辑上正确以及对开发人员足够详细

__因此，__ 编写格式上的细微差别是不可避免的，一旦用例通过了`QuittingTime`测试，编写人员就可以要求得到细微格式差别的"编写人员许可证"

编写每个用例，使其通过如下测试：

- 它遵循组织的编写模板和基本格式
- 它逻辑上是正确的
- 对最终评估人员来说，它是可读的
- 对实现人员来说它足够精确，可以使用

90%的用例前置条件都提供了"用户已登录"，尽管可能是有效的，但增加价值了吗？


用例集
========
对于系统中应该包括什么和不包括什么（更重要），每个人似乎都有自己的看法

缺乏清晰的边界所导致的结果是，参与者无处不在，好像只是看到了职位描述，就宣布他们为参与者，编写的用例名为

> 订票人：寻找航班
> 
> 代理人：寻找航班
> 
> 顾问：寻找航班

其他用例则使用CRUD来定义：

> 参与者创建数据
> 
> 参与者阅读数据
> 
> 参与者更新数据
> 
> 参与者删除数据

用例集模式是编写良好的 __一组__ 用例质量标志，不直接归因为某一个用例，它们描述了所有用例自然出现的属性

首先，对于系统的目的和目标，用例编写人员必须有一个`SharedClearVision`，为什么构建该系统？所有都知道并具有相同的愿景吗？对愿景的需要超出了用例的范围，因为如果项目参与人员不明确系统的目的，很可能会不恰当的假定一个目的

必须用一个限制系统范围的`VisibleBoundary`来限制愿景。该边界清晰的描述了什么属于系统，什么不属于系统。系统的责任是什么？哪些人以及其他哪些系统将与该系统交互？

`VisibleBoundary`有助于我们发现谁或什么能够与系统交互，谁在外部请求系统提供服务，以及谁在外部帮助系统提供这些服务，这些参与者是`ClearCastOfCharacters`。参与者包括人、组织、计算机系统或硬件

如果系统要实现`SharedClearVision`中规定的目的和目标，它必须为参与者提供什么服务？这些服务是`UserValuedTransactions`，它们为系统的参与者产生可测量的价值

我们将用例的结构组织为较高层的用例引用`EverUnfoldingStory`中较低层用例的形式。这种组织方式能够使读者在各种层次的细节上（取决于他们的需要）都把重点放在系统上

## SharedClearVision
认为编写一组用例将帮助涉众理解系统的功能需求，缺乏一个清晰的系统愿意可能会导致优柔寡断，涉众之间不能达成一致意见，并可能很快就使项目瘫痪

高效的用例编写人员对系统目的有一个清晰的愿景，并且确信参与系统开发的每个人都共享这一愿景

- 时间压力可能会使人过早地开发系统，他们的工作建立在错误假设的基础之上，使其步入正轨的代价可能会非常昂贵，构建人员只是列举系统的基本服务，创建用例时并不理解这些用例对要求提供服务的参与者的价值，许多CRUD用例都是构建时没有一个清晰的愿景所导致
- 构建人员有一种扩展系统范围的自然倾向
- 涉众之间有一些相互冲突的愿景
- 与外界隔离的人不知道项目的目标是什么
- 人员之间不进行交流

__因此，__ 准备一份清晰描述系统目标的系统目的陈述，确保其支持组织的使命，并将其直接分发给参与项目的每个人

愿景陈述中包括：

- 系统目标
- 系统将解决的问题
- 系统不会解决的问题
- 涉众是谁
- 系统将如何使涉众受益

该责任通常由某个营销人员承担，如产品经理，他还必须积极的与开发团队所有人员沟通，以确保他们对系统愿景具有相同的解释

通过获得那些将受系统影响的人的建议，验证系统愿景并寻求对该愿景的支持（`ParticipatingAudience`）

通过明确规定什么属于系统以及什么不属于系统，可以增强和限制系统愿景（`VisibleBoundary`，`ClearCastOfCharacters`）

确保愿景支持涉众的任务，并且出现在`UserValuedTransactions`中

最后，当系统愿景发生变化时，要确保所有的项目参与人员都能及时获悉这些变化

## VisibleBoundary
拥有系统的一个`SharedClearVision`，如果不知道系统的边界，系统的范围就会以一种不可控制的方式增长

- 对于系统的边界，不同的人有不同的观点
- 定义糟糕的边界会导致范围的蠕变
- 在项目初期，不准确的和相互冲突的目标通常导致确定系统的边界变化得难
- 人们认为定义边界是不必要的

__因此，__ 通过列举与系统交互的人员和设备，在系统与其环境之间建立一个可见的边界

`VisibleBoundary`通过以下方式限制和支持`SharedClearVision`：

- 指定系统必须与之协作的外部系统和人员，建立一个`ClearCastOfCharacters`
- 指定系统为完成其目的应该拥有的资源

在开发早期，系统愿景并不清晰，边界可能是模糊的，但随着用例的开发和对系统了解的加深，可以对系统边界进行求精和深化，进行`SpiralDevelopment`

## ClearCastOfCharacters
拥有系统目的的`SharedClearVision`，并建立了一个规定谁以及什么处于系统之外的`VisibleBoundary`，如果仅分析系统的用户，忽视他们在系统中所扮演的角色，就可能会遗漏重要的系统行为或引入冗余的行为

- 系统必须满足其用户的需要并保护其涉众的利益，只有这样的系统才是有用的
- 把服务和某些用户绑在一起可能会使系统变化非常死板，以致这些服务不能重用，一个用户可能会在系统中扮演许多不同角色，仅考虑不同的用户，可能使系统死板
- 主题专家的狭窄焦点或视野可能会使我们漏掉用户要求的服务
- 将重点放在用户身上可能会使人们纠缠于实现细节，而不是提供对用户所需要的服务的理解，过早的将实现细节引入分析，会引入风险
- 许多人都发现理解具体概念要比理解抽象概念容易
- 时间压力和权宜之计鼓励我们仅对用户进行分析，但要发现那个人正在扮演的角色需要花费更多的时间和努力

__因此，__ 识别系统必须与之交互的参与者，以及每个参与者和系统交互时 __所扮演的角色__，并清晰的描述每个参与者

通过把重点放在`UserValuedTransactions`或系统必须为用户提供的一组服务上来分析系统。

对于每个用户，确定并列出用户要求系统提供的服务，尽量将服务组织为内聚的集合，然后对这些集合命名，仔细寻找具有重叠服务集合的用户，查找背后的角色

如果不能立即找到所有角色，也许会出现在`SpiralDevelopment`周期中

## UserValuedTransactions
已经建立了项目的`SharedClearVision`，并且定义了一个需要系统提供服务的`ClearCastOfCharacters`，如果系统不能为其用户提供有价值的服务，不支持系统愿景所规定的目的和目标，那么，系统就是不完善的

- 读者应该能够轻松看到系统是如何满足其目标的

__因此，__ 识别系统为参与者提供以满足其业务目的的有价值服务（解决方案）

使用`ClearCastOfCharacters`和`SharedClearVision`识别系统应该提供的服务。为列表中每个参与者定义尽可能多的有价值的服务，每项服务必须帮助至少一个参与者实现一个目标

围绕这些目标编写用例，应该使集合中用例的数量最少，但每个用例都应该是一个内聚的单元，它描述了参与者和系统之间一个且只有一个关键概念，即`CompleteSingleGoal`。用足够的细节描述该集合，但又有一个足够高的抽象层上，以使其能够与简单变更隔离

在`BreadthBeforeDepth`中，参与者的名称和对用户有价值的事务的名称构成了在应用`SpiralDevelopment`前，用例应该具有的最初深度

示例

> 预订旅行
> 
> 搜索航班
> 
> 筹划度假事宜
> 
> 创建旅行路线
> 
> 更新旅行路线
> 
> 删除旅行路线

所有这些服务都有价值吗，预订旅行、搜索航班、筹划度假事宜是成功旅行社保持业务运营需要做的事，但，后三者大概就不能代表用户有价值的那些目标了，每一项服务都是更大服务的一部分，如预订旅行包括创建旅行路线，更改成如下：

> 预订旅行
> 
> 更改预订
> 
> 取消预订
> 
> 搜索航班
> 
> 筹划度假事宜

有能犯的错误，为每个用户界面表单或外部协议消息创建用例，结果是产生了一组为主参与者增加微小价值的很小用例，如 获得航班信息 获得客户信息 获得支付信息

它们描述了从某张表单中获得信息并对其处理所需要的步骤，但为客户预订机票的过程，该目标仅是其中一小步

在编写这种用例时，很容易遗漏上下文，怎么知道这些用例与预订机票有关

这些用例没有反映参与者的观点，从系统角度而 __非参与者角度__ 编写用例

## EverUnfoldingStory
正在组织`UserValuedTransactions`，以使它们所处的上下文及其结构是清楚的。描述系统行为所需的步骤已超出了所有读者的记忆和兴趣范围

- 每个用例都可能有许多读者和很多使用方式，它们要求不同的详细级别
- 用例需要展示每项功能如何为业务贡献自己的价值
- 然而，在多个层次编写用例会让人感到混乱
- 编写人员需要遵循一个原则来对需求进行组织

__因此，__ 将一组用例组织分层故事的形式，可以将其展获得更多的细节，也可以将其折叠起来的隐藏细节，显示更多的上下文

正如要用不同的比例尺来绘制地图以展示或隐藏细节一样，可以在不同的抽象级别编写用例。一组好的用例包含相关用例的几个内聚层次，这些用例在不同的抽象级别对系统进行了完整描述，每个下层用例与其上层用例非常相似，但包含了更多的细节

每个用例都在它所处的层次捕获一个`CompleteSingleGoal`，在更高层次的用例中，该目标是一个步骤`ActorIntentAccomplished`，较低层的用例则展示该实现细节

- 概要级，需要用多个用户目标会话来完成，如预订旅行
- 用户目标级，满足了主参与者当前的特定价值目标，它一般由一个主参与者在一个位置执行，如预订旅行，分为，预订航班，预订旅馆
- 子功能级，满足了用户目标级用例或另一个子功能的部分目标，如预订航班又分为，寻找航班，预约座位

示例

> __预订航班__
> 
> __级别__：用户目标
> 
> __主成功场景__
> 
> 1.当客户打电话请求预订航班时，该用例开始
> 
> 2.客户通过说明其始发地、目的地、旅行日期和偏好的飞机起飞时间来描述其航班需要
> 
> 3.系统查询与客户的旅行偏好匹配的所有航班，并为客户提供旅行选择
> 
> 4.客户选择一个航班
> 
> 5.系统为客户构建一条航班路线
> 
> 6.系统为客户预约航班
> 
> 7.客户提供一个信用卡号，系统从该信用卡中收取应付的机票费用
> 
> 8.系统出票给客户

一个较低层用例

> __寻找航班__
> 
> __级别__：子功能
> 
> __主成功场景__
> 
> 1.当客户与旅行社联系请求预订航班时，该用例开始
>
> 2.旅行社获取客户旅行的始发地和目的地
>
> 3.旅行社查询始发地和目的地的机场代码
>
> 4.旅行社获取客户喜欢的飞机起飞时间
>
> 5.旅行社获取客户喜欢的服务类别
>
> 6.旅行社确认客户的偏好是正确的
>
> 7.系统请求航线预约系统提供一个与客户的偏好相匹配的航班列表，该列表要提供给旅行社

一些人使用“包含”和“扩展”关系来实现该解决方案，但许多人对这两个概念的解释是不一样的，可能引起混淆

建议使用反向的虚线，并加上`<<trace>>`来表示依赖关系

用例
======
用例不应该有多个主要故事或主要故事片断，它应该实现支持系统愿景的一个完整目标，称为`CompleteSingleGoal`，参与者或者实现了这一目标，或者未能实现该目标

参与者有许多可以实现或不能实现目标的可选方法，用例必须将所有可能的不同操作过程描述为`ExhaustiveAlternatives`

应该如何在一个用例中提供所有这些不同的线索？每个可能分支详尽的编写它自己的故事，还是用嵌套的if语句？任何一种方式都不令人满意，因为人们发现详尽的场景是冗余的，适当的方法是将不同的分支结构化为`ScenarioPlusFragments`，其中将实现`CompleteSingleGoal`所期望的方式编写一个称为场景的简单情节，然后，将每个分支编写对故事内容的不断添加，即所谓的片断

用例应该有一个好标题，`VerbPhraseName`，它能够提醒读者注意用例的目标

好的故事必须是可读的，用例应该`PreciseAndReadable`

## CompleteSingleGoal
正在编写`EverUnfoldingStory`，重点是`ClearCastOfCharacters`，不适当的目标会使编写人员不能确定什么时候一个用例结束，什么时候另一个用例开始

- 为了构建正确的系统，我们需要理解参与者如何获得一些价值实现
- 应该通过把用例划分为对涉众有意义的几部分来控制复杂性
    + 参与者目标的持续时间可能会发生变化，有可能几天才能完成目标
    + 太大的用例可能因细节过多占去涉众的在部分精力
    + 大的用例会限制重用
    + 过小的用例仅能描述某些价值实现的一部分
    + 主题专家的有限知识可能会使我们编写出小的用例


__因此，__ 将编写每个用例，用来表述一个完整而且定义良好的目标，该目标可以位于`EverUnfoldingStory`的任何一级上

用希望突出的`VerbPhraseName`选择和命名主参与者目标，可能需要几秒、几天、几周或几个月来完成目标，它可以在任何级别上。

一个目标的出色特性为：

- 它与一个定义良好的参与者相关
- 它对参与者或参与者所代表的涉众是有价值的
- 它与这一级别上为系统确定的其他目标一致

用例应该`PreciseAndReadable`，描述主参与者可以实现或不能实现该目标的不同方法，将用例结构化为`ScenarioPlusFragments`，主成功场景描述了令人满意的情况，该主成功专后是一组描述所有合理分支的片断，在参与者试图实现目标时，这些分支可能会对其造成影响

## VerbPhraseName
已识别了一个与`CompleteSingleGoal`相关的用例，没有意义的普通名称不会使读者有什么期望，也不会提供一个方便的参考点

- 名称为读者确定了基调和关联，并能够为编写人员提供一个焦点
- 一个适当的名称为用例提供一个句柄
- 适当的用例名称能够使人看到大的概貌，并且对整个用例集有效

__因此，__ 用一个代表主参与者目标的主动动词短语来命名用例

不好的名称：索赔过程，处理材料

好的名称：提出事故索赔申请，批准财产损坏索赔

## ScenarioPlusFragments
正在为主参与者的`CompleteSingleGoal`编写用例描述，读者必须能够非常轻松的阅读具体的场景或他们感兴趣的故事，否则，他们很可能会变得沮丧，或遗漏重要的信息

- 一个有趣的用例需要捕获主成功场景的分支
    + 将每个分支编写为一个完整的故事将会模糊故事变体之间的差别
    + 将每个变体分离出来也会使编写人员的工作变得非常困难
    + 大量的if语句会命名故事变得乱糟糟
    + 人们能够很好的就会渐增的复杂性
- 需要清晰地确定主成功场景

__因此，__ 将成功的故事情节编写为简单场景，不考虑任何可能的失败。在该场景下面，放上展示会发生什么情况的故事片断

主功能场景描述主参与者如何以一种简单的方式实现目标，不一定是最短或唯一可能的成功路径，__但它应该是实现该目标通常期望的路径__，也是用户最有可能遵循的

对每一个必须考虑的`ExhaustiveAlternatives`，在主成功场景之后创建一个抬头，首先描述导致参与者采用该分支的`DetectableConditions`，然后描述在这一分支中会发生什么，以及如何结束：或者重新结合到主要故事中，或者以失败结束

用例中每个场景都应该有一个清晰的目的，将用例中的每个场景编写为一组的`LeveledSteps`，其中，每个`LeveledSteps`都显示了`ActorIntentAccomplished`，从而使得`ForwardProgress`朝着用例的`CompleteSingleGoal`方向发展

通常片断以一种相当明显的方式结束的：重试分支以前的步骤，修复该步骤以使它能够与主成功场景的下一步骤结合在一起，或者完全失败，有时有必要明确指出故事又结合在一起的地方

有时，一些片断会变得很长很复杂，因而模糊了用例的其余部分，为了`PreciseAndReadable`，此时创建一个`PromotedAlternative`是有帮助的，提取分支并将其放到一个单独的用例中

根据`BreadthBeforeDepth`，该模式识别以下这些停止点：

- 主成功场景
- 为条件命名
- 完成某些片断

示例

> __获得交通事故赔偿__
> 
> __主参与者__：
> 
>   索赔人－提出索赔要求事故受害人
>   
>   保险公司－为索赔人承保的公司
>   
>   代理人－处理索赔的保险公司代表
>   
> __级别__：概要
> 
> __主成功场景__
> 
> 1.索赔人用具体的数据提出索赔申请
>
> 2.保险公司核实索赔人拥有有效的保险单
>
> 3.保险公司派代理人检查情况
>
> 4.代理人验证所有情况都在保险单所列责任范围之内
>
> 5.保险公司向索赔人支付赔偿金
> 
> __扩展__
> 
> 1a.提交的数据不完整
> 
>> 1a1.保险公司请求提供遗漏的信息
>   
>> 1a2.索赔人提供遗漏的信息
>   
> 2a.索赔人的保险单无效
> 
>> 2a1.保险公司拒绝赔偿，通知索赔人，记录所有情况，并中止理赔
> 
> 3a.此时没有代理人
> 
>> 3a1.（此时保险公司做什么？）
> 
> 4a.事故违反了基本的保险政策
> 
>> 4a1.保险公司拒绝赔偿，通知索赔人，记录所有情况，并中止理赔
> 
> 4b.事故违反了一些较小的保险政策
> 
>> 4b1.保险公司就赔偿金的支付额度与索赔人协商

## ExhaustiveAlternatives
正将用例编写为`ScenarioPlusFragments`，用例可以有许多分支，遗漏一些分支意味着开发人员会误解系统的行为，这样的系统是不完善的

- 开发人员需要知道如何处理错误，否则会按自己方便的方式来处理
- 进度压力限制了开发人员可以识别各种变化的时间
- 一些变化处理策略需要进行大量调查
- 拥有关于变化的信息有助于开发人员构建一个健壮的设计

__因此，__ 捕获必须在用例处理的所有分支和失败情况

捕获想让系统处理的所有变化，然而也可以是有选择的，这些变化应该是`DetectableConditions`，它们或由于用户以不同的方式使用系统导致，或者由错误条件产生。消除从系统不能或没必要检测的条件开始的所有变化，然后合并产生相同行为的所有变化

`BreadthBeforeDepth`方式编写用例时，在以在花大量时间进行扩展处理前，__发现那些导致不同路径的所有分支条件__，条件列表作为以后需要研究问题的内容列表

这是`BreadthBeforeDepth`方式编写用例时第三次停下来检查的时候，第一次是命名了参与者和`UserValuedTransactions`，第二次是编写了主成功场景后

示例

> __访问电子邮件__
> 
> __主参与者__：读者－阅读电子邮件的人
> 
> __级别__：用户目标
> 
> __主成功场景__
> 
> 1.读者通过登录系统并请求电子邮件来启动用例
> 
> 2.服务器显示读者的电子邮件界面
> 
> 3.读者和服务器无限重复以下步骤
> 
> 4.读者选择电子邮件
> 
> 5.服务器显示电子邮件并其标记为已阅读
> 
> 6.读者选择“退出”选项
> 
> 7.服务器更新读者的电子邮件账户信息并注销读者
> 
> __分支路径__
> 
> 读者保存电子邮件
> 
>> 4.读者选择“保存电子邮件”
>> 
>> 5.服务器将电子邮件标识为未阅读
> 
> 读者回复电子邮件
> 
>> 4.读者选择“回复”
>> 
>> 5a.服务器提示读者回复
>> 
>> 5b.读者输入回复并指示服务器发送电子邮件
>> 
>> 5c.服务器将电子邮件发送到消息发送者的地址
> 
> 读者将电子邮件转发给另一个读者
> 
>> 4.读者选择“转发电子邮件”
>> 
>> 5a.服务器请求提供地址
>> 
>> 5b.读者提供地址信息并指示服务器发送电子邮件
>> 
>> 5c.服务器将电子邮件转发到指定的地址
> 
> __错误路径__
> 
> 无效登录
> 
>> 1.读者提供不正确的登录标识和密码
>> 
>> 2.服务哭显示错误信息并启动一个新的登录序列

## Adornments
将用例描述为`ScenarioPlusFragments`的形式，使步骤保持`TechnologyNeutral`，在用例中包含非功能需求很快就会将用例搞乱并模糊用例

- 用例的目的是清晰的表达系统的 __功能需求__，不管技术背景如何，一般人看到用例时，都应该能够很快的理解它所描述的功能
- 在研究功能需求，我们通常会了现非行为信息，在收集系统需求时，通常会收集到所有有价值的信息，如要执行操作的类型或支持的用户数量，其他部分并不直接反映到需求中，但会对需求进行澄清和说明，如报告样本，GUI示例或生成的数据文件
- 在用例中包含非功能需求会分散人的注意力
- 不应该遗漏有助于理解用例或对开发人员来说有价值的信息，如单独文档中存放，但这样失去了非功能性需求和用例之间关联的上下文

__因此，__ 在用例模板的场景文本之外创建额外区域，来容纳对关联用例有用的补充信息，如业务规则、GUI草图、外部接口协议、数据验证规则等

业务规则与分支：

- 用例中没有描述业务规则，读者可以清晰的看到事件流
- 不应该将每个业务规则导致的不同分支描述出来，不符合的业务规则只有一个分支，它们结果是相同的，`DetectableConditions`
- 业务规则不论何时发生变化，都没有必要更新用例场景

## PreciseAndReadable
正在将用例的文本编写为`CompleteSingleGoal`，对非技术性读者来说太过复杂，或对开发人员来说不太精确的用例是不完善的，很可能会导致构建不良且不适当的系统

- 对于涉众和开发人员来说，用例应该都是可读的
- 开发人员有一种添加细节和解决方案的倾向
- 非技术涉众在理解技术性太强的文档时，很可能会遗漏一些必要的考虑
- 应该鼓励涉众和开发人员进行交流，以确保需求的准确性
- 双重模型是不可接受的，因为它们可能会变得混乱，而且难以维护

__因此，__ 用例需要足够可读，以便涉众可以阅读和作出评估；用例要足够精确，以便开发人员可以理解他们正在构建的系统

使用简单的语言描述基本的系统行为，保持步骤`TechnologyNeutral`，仅包含描述系统行为所必需的信息

场景和步骤
==========
用例中有20个分支，因为将业务规则放在了用例中，而且对每个不同的故障都有一个分支。我们有一个称为`DetectableConditions`的原则，论述了作为一组不同条件的结果，如果采取的操作是相同的，那么，它们就是相同的条件，通过消除冗余的分支来帮助降低用例的复杂性

每个用例步骤中都必须清楚谁在说话和表演，`ActorIntentAccomplished`建议每个步骤都要清晰地描述完成什么以及谁负责完成它

场景中每个步骤都必须使`ForwardProgress`朝着主参与者的目标方向前进，不朝着目标方向的没有意义的，而且不在用例范围之内，只能分散读者注意力

`DetectableConditions`建议每个场景都应该是 __可以实际发生或由系统检测的，而不是列出所有想像得到的分支__

每个步骤和场景都应该`TechnologyNeutral`，技术约束和建议、用户界面和业务规则这些东西作为`Adornments`提供的补充

永远不要为读者编写复杂、价值不高且处于不同抽象层次的用例。出色的用例具有`LeveledSteps`的场景组，其中每个步骤都在相似的范围内

## DetectableConditions
正在为用例结构化可能会在不同条件下发生的`ExhaustiveAlternatives`，编写人员总了绞尽脑汁地思考包括多少条件以及包括哪些条件

- 系统不能处理它检测不到的事件
    + 开动小汽车用例，丢失钥匙、钥匙坏了导致相同的条件，汽车不能启动，尽管每个条件解决方法不同，但汽车计算机并不关心这一点，它只知道汽车不能启动
    + ATM插入一张严重擦伤的卡和倒置插入卡，结果都是卡不可读
- 开发人员需要知道检测什么条件
- 害怕忽视重要的分支使得开发人员叙述系统检测不到的不相关的条件
- 很多从表面看起来不同的条件可能会导致编写不必要的分支

__因此，__ 只包含 __可检测的条件__，合并对系统最终影响相同的条件

用例中每个场景都必须以系统能够检测到的操作开始，否则，系统将永远不能执行场景，编写那样的场景只是浪费时间，而且有可能会引入不必要的使系统复杂化的特性，不能提出一个可检测的条件来启动场景可能预示着该场景并不属于用例的范围

示例，ATM不能检测油墨不足，可派人定期检查，而不是由ATM本身来检测

> __取款__
> 
> __级别__：用户目标
> 
> __主功能场景__
> 
> 1.客户插卡
> 
> 2.ATM验证卡片是可读的并且是合法的
> 
> 3.客户输入PIN并选择“快速提现金”
> 
> 4.ATM向主银行计算机系统（BCS）发送账号、PIN以及现金提取请求，系统将返回同意取款的信息
> 
> 5.ATM吐出两张20美元的钞票，将卡返回给客户并打印凭条，记录这些操作，然后向BCS确认已经提供了现金
> 
> 6.客户拿走现金、卡和凭条
> 
> 7.ATM重新恢复到可以取款状态
> 
> __扩展__（此处仅提供可检测的条件）
> 
> a.在操作中突然检测到了电源故障
> 
> 1a.卡留在读卡机中
> 
> 2a.卡不可读
> 
> 3a.PIN输入或功能选择超出允许的时间范围
> 
> 4a.无法联系到BCS
> 
> 4b.BCS拒绝交易
> 
> 4c.出钞器的现金不足
> 
> 5a.ATM检测到送错了现金（少或多）
> 
> 5b.现金卡在了出钞器中
> 
> 5c.客户没在时间限度内取走现金
> 
> 5d.客户没有在时间限度内取卡

每个分支描述了可以合理的期望ATM检测到的操作，因为每个步骤解决了一个真实的条件，因此没有重复

## LeveledSteps
把用例的步骤编写为`ScenarioPlusFragments`的形式，过大过小的用例步骤会模糊目标，并会使用例难以阅读和理解

任何事情都可以用越来越小的步骤描述，直到该步骤失去意义

- 过小的步骤使得用例不仅冗长而且难以阅读，它们模糊了“为什么”
- 过大的步骤可能会掩盖重要的行为
- 在场景中，使用不同的详细级别编写会分散读者的注意力

__因此，__ 将场景保持在3~9步内，理想情况下，步骤是在类似的级别编写，并且是仅在用例目标之下的抽象级别

编写的每个步骤来显示`ActorIntentAccomplished`，参与者使不同的`ForwardProgress`朝着目标前进，使每个步骤`TechnologyNeutral`，使步骤在抽象级别的目标 __低于__`CompleteSingleGoal`。

通过询问为什么用户和系统做这些工作，试图完成什么

> 系统显示登录屏幕
> 
> 用户输入用户名和密码
> 
> 系统验证用户输入的信息
> 
> 系统设置访问权限
> 
> 系统显示主屏幕

上述的目的就是 用户想登录系统

## ActorIntentAccomplished
将场景的步骤编写为`LeveledSteps`，如果对哪个参与者负责执行步骤，以及参与者在该步骤中试图完成什么表述得不够清晰，读者和开发人员就会对系统的行为感到困惑

- 开发人员需要清楚的知道他们要实现什么，系统在什么时间应该等待输入信息，以及系统在什么时候应该采取行动

__因此，__ 编写每个步骤，清楚的显示哪个参与者在执行操作，以及参与者完成了什么工作

当参与者在每个步骤中可见时，对于评审人员和开发人员来说，哪个参与者必须执行该步骤就很清楚了

示例，没有参与者的ATM机

> __取款__
> 
> __主参与者__：用户
> 
> __级别__：用户目标
> 
> __主成功场景__
> 
> 1.读取ATM卡
> 
> 2.验证卡信息
> 
> 3.收集交易信息
> 
> 4.验证交易信息
> 
> 5.吐出现金并更新账户
> 
> 6.系统复位

改进版本

> __取款__
> 
> __主参与者__：用户
> 
> __级别__：用户目标
> 
> __主成功场景__
> 
> 1.用户插入其ATM卡
> 
> 2.系统读取并验证卡信息
> 
> 3.用户选择交易交输入交易细节
> 
> 4.系统验证交易细节
> 
> 5.用户收取现金并取卡（用户的目的）
> 
> 6.系统更新账户并复位系统

被动语态编写也是不合适的。

带有具体技术步骤的描述，也是不合适的，如

> 1.系统请求输入姓名
> 
> 2.用户输入姓名
> 
> 3.系统提示输入地址
> 
> 4.用户输入地址
> 
> 5.用户点击OK
> 
> 6.系统提供用户的资料

可通过将步骤组合在一起，使用例`TechnologyNeutral`，并获取参与者的意图来改进编写，而不是使用具体的技术动作，改进如下：

> 1.用户输入姓名和地址
> 
> 2.系统提供用户的资料

## ForwardProgress
正在将场景的步骤编写为`LeveledSteps`，编写人员必须决定在任何一个步骤中包含多少行为。他们很容易编写太多的细节，使得用例冗长乏味而且难以阅读

- 清晰简洁的步骤减少了理解和评估用例所需要的精力
- 对完整性和细节的期望可能会导致包含偏离用例目标的步骤

__因此，__ 消除或合并对参与者没有推进作用的步骤。简化会分散读者对目标实现注意力的内容

只要没有删除必要的信息，简化用例有助于阅读，如果有代表了重要分支的离题步骤，那么将它们作为分支放到场景中`ScenarioPlusFragments`，如果认为有细节对理解故事很重要，将它们作为`Adornments`

示例

> __请求升级__
> 
> __主参与者__：旅行者－已购票乘客
> 
> __级别__：用户目标
> 
> __主成功场景__
> 
> 1.旅行者输入他的航班账号代码，并请求座位升级
> 
> 2.如果旅行者是一个飞机常客，那么，系统显示他当前飞过的里程数以及最近的飞行活动
> 
> 3.系统验证有可供升级的座位
> 
> 4.系统升级旅行者的座位分配，从客户账号中删除适当的升级证书
> 
> 5.在请求升级时，旅行者还可以购买更多的升级证书，系统为客户提供一个升级凭条

示例中，步骤2和步骤5会将读者的注意力从旅行者如何请求座位升级的真正故事上转移开：

- 步骤2确实是步骤1的分支，处理那些客户是飞行常客的情况
- 当旅行者没有足够的升级证书时，步骤5是步骤4的分支

改进后如下：

> __请求升级__
> 
> __主参与者__：旅行者－已购票乘客
> 
> __级别__：用户目标
> 
> __主成功场景__
> 
> 1.旅行者输入他的航班账号代码，并请求座位升级
> 
> 2.系统验证有可供升级的座位
> 
> 3.系统升级旅行者的座位分配，从客户账号中删除适当的升级证书，系统为客户提供一个升级凭条
> 
> __分支__
> 
> 1a.旅行者是一个飞机常客
> 
>> 1a1.系统显示他当前飞过的里程数以及最近的飞行活动
> 
> 3a.旅行者没有足够的升级证书
> 
>> 3a.1旅行者还购买额外的升级证书

另一个示例是，没有“足够的”向前进展，连续几个步骤指的都是相同的参与者，执行一个又一个操作，需要考虑一下在每个步骤中是否进行了足够的向前进展。在进行`LeveledSteps`的过程中，问一下“参与者试图完成什么”以及“能否找到一种方法在一个步骤中表示所有这些信息吗”


> __保险索赔__
> 
> __主参与者__：索赔人－报告事故索赔的持保人
> 
> __级别__：概要
> 
> __主成功场景__
> 
> 1.索赔人获得索赔申请表
> 
> 2.索赔人在索赔申请表上输入姓名和地址
> 
> 3.索赔人在索赔申请表上输入保险单信息
> 
> 4.索赔人在索赔申请表上输入事故信息
> 
> 5.索赔人复印传票，并把它附在索赔申请表上
> 
> 6.索赔人复印索赔申请表，并把它放在档案柜中
> 
> 7.保险公司检查索赔人是否拥有有效的保险单
> 
> 8.保险公司确定索赔人确实拥有一张有效的保险单
> 
> 9.保险公司派一名代理人来检查情况
> 
> 10.代理人验证所有情况都在保险单的条款范围内
> 
> 11.保险公司支付索赔人

步骤1到5是该过程的必要组成部分，但几乎没有实现总体进展，浪费了读者很多精力，可以表达成：

> 1.索赔人提交填写了具体数据的申请表

步骤6并没有为用例带来任何向前进展，是多余的，索赔人可能想保留其索赔申请表一副本，但这与用例无关，保险公司都会给处理索赔申请，可删除

步骤7说“检查是否”，表示编写人员必须再编写一个说出结果的句子，验证失败将以一种 __扩展条件__ 的方式出现，步骤7、8应描述为：

> 2.保险公司验证索赔人拥有有效的保险单

改进后如下

> __保险索赔__
> 
> __主参与者__：索赔人－报告事故索赔的持保人
> 
> __级别__：概要
> 
> __主成功场景__
> 
> 1.索赔人提交填写了具体数据的申请表
> 
> 2.保险公司验证索赔人拥有有效的保险单
> 
> 3.保险公司派一名代理人来检查情况
> 
> 4.代理人验证所有情况都在保险单的条款范围内
> 
> 5.保险公司支付索赔人

## TechnologyNeutral
将场景步骤编写为`LeveledSteps`，保持用例`PreciseAndReadable`。在用例描述中包含技术约束和实现细节会提高复杂性，并且会模糊用例的目标

好的用例应该把读者与具体系统细节隔离开，从而使他们能够把精力放在系统的基本行为上

- 许多人都喜欢用具体词语来思考问题，不能对不理解的事物进行抽象，要努力得到具体的细节以增加知识，在条件具体情况下，对一个主题进行抽象思考
- 技术是不稳定的，包含具体技术的细节将会导致返工
- 技术细节对未来的活动产生了不适当的约束
- 添加技术细节提高了阅读和编写用例的成本
- 有时添加技术细节是一种需要

__因此，__ 以一种 __技术中性__ 的方式编写每个用例

将重点放在基本的系统行为上，如系统执行什么操作，为什么有人可能想进行这些操作，以中性方式描述具体的操作

使用“用户请求系统提供信息”，而非“用户从下拉式菜单”这样的短语

进行了设计假设，很可能不是需求，会阻止开发人员检查和实现其他更有效的机制

如果有与用例相关或有助于提高理解的实现细节的技术约束，作为`Adornments`

用例关系
=========
“包含”和“扩展”不管是初学者还是有经验的人员都容易糊涂，这些本来用来简化模型的，有可能起了相反的作用

该分支是否非常复杂和分散人的注意力，以至于应该创建一个`PromotedAlternative`，还是这些用例是否包含一组公共的步骤，将其取出来作为`CommonSubBehavior`，这些才是对项目有用的

过度使用“扩展”关系模型，通常使用它来描述实现细节，频繁描述关于用户界面的分支，导致读者陷入细节，忽略了重要的参与者目标

有助于用例编写人员理解的3种模式：

- `CommonSubBehavior`论述了当两个或多个用例共享一组公共的操作时，应该考虑在用例之间创建包含关系，目的是合并公共的行为，并通过减少冗余来简化模型
- `InterruptsAsExtensions`建议在分支中断了场景中的大量步骤时，考虑一个扩展用例。该方法合并一个用例中相关中断操作，而不是将它们分散在几个分支的操作过程中，因而有助于简化模型
- `PromotedAlternative`建议当强调一些重要的分支时，可以使用扩展。在这种情况下，可以将这些分支提升为扩展用例，以使它们突出出来。在使用该方法时应该谨慎一些，以使它们不与在`InterruptsAsExtensions`或`RedistributeTheWealth`中描述的指导原则冲突

## CommonSubBehavior
将用例描述编写为`ScenarioPlusFragments`，为不同的用例编写相同的步骤不仅浪费时间和精力，而且更难在一个用例模型中看到公共的子过程

- 重新编写公共的步骤是多余的，而且会提高模型中不准确性和不一致的风险
- 划分单个用例很可能会分散重要的行为，并且会使用例更难理解
- 误解“包含”关系会导致误用，并非程序中模块和子模块的关系，那是分解技术，而此处重要的共用

__因此，__ 用较低层的被“包含”用例表达共享的动作路径

避免仅把“包含”用作冗长复杂的用例划分为较小用例的机制，冗长复杂的用例一般存在以下几个问题：

- 用例的范围太大，请识别`CompleteSingleGoal`和`RedistributeTheWealth`
- 为了实现用例的目标，用例的步骤是在太低的详细级别编写的，或者是在不同的详细级别编写的，需要使用`LeveledSteps`
- 用例中有诸如用户界面细节这样的非功能需求，把它们放在`Adornments`

误用示例，预订航班 包含 获取航班需求、预约航班段、获取支付信息、出票 四个用例，这种包含，没有什么价值，太简单，根本不值得作为整个用例的存在，“包含”的用例就是Droplet，处理就是`MergeDroplets`

但是，当预订游船和预订航班，都需要收集支付信息，后者就可以作为被包含用例

被包含的行为 __总是__ 被执行，它永远也不会是扩展或分支场景的一部分

## InterruptsAsExtensions
将用例描述编写为`ScenarioPlusFragments`的形式，影响场景中多个步骤的分支会把相关细节分散在用例中，这样会遗漏重要的信息或者使读者感到混乱

- 多次偏离(diversion)或打断场景中几个步骤的分支可能会使读者失去他们正在试图理解的路径的线索，可能表明基本场景本身存在问题
    + 建议把分支编写为主成功场景之外的片断（`ScenarioPlusFragments`），该方法对大多数分支都能奏效
    + 然而，当分支需要在不止一个步骤产生重复偏离时，可以为每个步骤编写一个偏离，但读者很容易失去将这些相关偏离连在一起的分支的线索
- 创建扩展用例很容易分散重要的行为，并使它们更难理解
- 误解“扩展”关系会导致扩展的误用，问五个专家会得到十个不同的答案

__因此，__ 当分支动作路径中断了一个场景中的大量步骤时，创建一个扩展用例

这种情况很隐晦，不会经常出现，如果频繁使用该模式，应该重新评估用例，可能还没有`CompleteSingleGoal`，或还没有`LeveledSteps`

通过提取与分支的线索相关的所有步骤并把它们放在一个扩展用例中来，对于扩展用例中每一个语句，指出原始用例或基本用例中哪个语句被中断了：
    
- 中断分支的线索不分散，因此可以看到分支的上下文
- 中断分支没破坏原始用例或基用例

示例，预订航班的主成功场景相对简单，但如果客户是常客的话，主成功场景中许多步骤都有扩展

> __预订航班__
> 
> __主成功场景__
> 
> 1.当代理人说明客户的旅行路线时，用例开始
> 
> 2.系统搜索一组符合条件的航班并将它们提供给代理人
> 
> 3.代理人“选择航班”
> 
> 4.系统验证航班上还有座位并预约座位
> 
> 5.代理人提供支付信息，结束预订
> 
> 6.系统预订座位并出票
> 
> __分支路径__
> 
> 2a.客户是一个飞行常客
>
>> 2a1.系统检索客户的资料，并显示根据客户的航班线偏好进行分类的航班
>
> 4a.客户是一个飞行常客
>
>> 4a1.系统为客户提供头等座位
>
> 4b.在选择的票类中没有座位可以提供
>
>> 4b1.系统通知代理人，在客户选择的票价类别中没有座位可以提供
>> 
>> 4b2.代理人指定另一种价格偏好
>
> 4c.没有座位可以提供（航班座位已满）
>
>> 4c1.系统通知代理人根本没有座位可以提供
>> 
>> 4c2.代理人说明另一组客户喜欢的起飞时间
>
> 4d.客户是一个飞行常客，没有座位可以提供
>
>> 4d1.代理人将客户放在一个座位等待优先级清单上
>
> 5a.客户是一个飞行常客
>
>> 5a1.系统验证客户已经升级了账号中的优惠券
>> 
>> 5a2.系统把客户列入航班升级清单

此时可通过使用扩展用例 “预订航班飞行常客” 扩展自 “预订航班”

> __为飞行常客预订航班__
> 
> __扩展 “预订航班”__
> 
> 2a1.系统检索客户的资料，并显示根据客户的航班线偏好进行分类的航班
> 
> 4a1.系统为客户提供头等座位
> 
> 5a1.系统验证客户已经升级了账号中的优惠券
> 
> 5a2.系统把客户列入航班升级清单
> 
> __分支__
> 
> 4d.没有座位可以提供
> 
>> 4d1.代理人将客户放在一个座位等待优先级清单上

扩展用例并 __不独立__ 于基用例，必须引用基用例中的语句，UML中扩展点特性通过为扩展用例提供扩展点，如上例中扩展点为 “飞行常客abcd”，__缓解了__ 基用例中语句编号发生变化，扩展用例也要改变的情况

示例，具的扩展点的“预订航班”

> __预订航班__
> 
> 1.当代理人说明客户的旅行路线时，用例开始
> 
> 2.系统搜索一组符合条件的航班并将它们提供给代理人
> 
> （飞行常客a）
> 
> 3.代理人“选择航班”
> 
> 4.系统验证航班上还有座位并预约座位
> 
> （飞行常客b）
> 
> 5.代理人提供支付信息，结束预订
> 
> （飞行常客c）
> 
> 6.系统预订座位并出票
> 
> __分支__
> 
> 4a.在选择的票类中没有座位可以提供
>
>> 4a1.系统通知代理人，在客户选择的票价类别中没有座位可以提供
>> 
>> 4a2.代理人指定另一种价格偏好
>
> 4b.没有座位可以提供（航班座位已满）
>
>> 4b1.系统通知代理人根本没有座位可以提供
>> 
>> 4b2.代理人说明另一组客户喜欢的起飞时间
>> 
>> （飞行常客d）

引用了扩展点的“为飞行常客预订航班”扩展用例

> __为飞行常客预订航班__
> 
> __扩展“预订航班”__
> 
> 飞行常客a
> 
> 1.系统检索客户的资料，并显示根据客户的航班线偏好进行分类的航班
> 
> 飞行常客b
> 
> 1.系统为客户提供头等座位
> 
> 飞行常客c
> 
> 1.系统验证客户已经升级了账号中的优惠券
> 
> 2.系统把客户列入航班升级清单
> 
> __分支__
> 
> 没有座位可以提供
> 
> 飞行常客d
> 
> 1.代理人将客户放在一个座位等待优先级清单上

## PromotedAlternative
将用例描述编写为`ScenarioPlusFragments`的形式，冗长或复杂的分支可以占据用例的大部分，因为它们非常突出，所以导致其重要性被夸大

有时一个分支场景很突出，它突然变得很重要了，因为它填补了系统中一个重要的漏洞，当它起到了这样的作用时，将提升为用例就很有意义

- 复杂或冗长的分支会搞乱一个用例，并且会模糊其他分支
- 一些问题非常复杂，它们要求复杂的用例对其进行充分描述
- 划分单个用例容易分散重要的行为，并且会使它们变得更难以理解

__因此，__ 考虑将过分支配用例的复杂分支转移到一个单独的用例中

分支动作路径永远也不应该支配用例，它代表了与主成功场景相比不太常见的行为。但有时会具有一系列冗长复杂步骤的分支（如control break和边界条件），在这些情况下，可能会考虑将分支从基用例中提取出来，为其创建一个单独的用例

在使用该模式时要小心，因为复杂的分支可能意味着过于详细或过大（`EverUnfoldingStory`，`LeveledSteps`，`CompleteSingleGoal`，`RedistributeTheWealth`），如果不是这些情况时，那么将分支提升它自己的用例是一个合理的操作过程

示例，“座位升级”分支模糊了其他分支，并支配了用例，可以把它编写一个单独的用例，但如何从最初的用例中引用它就是另外一个问题了，一种认为是“包含”，另一种观点认为使用“扩展”

原始用例

> __预订航班__
> 
> 1.当代理人说明客户的旅行路线时，用例开始
> 
> 2.系统搜索一组符合条件的航班并将它们提供给代理人
> 
> 3.代理人“选择航班”
> 
> 4.系统验证航班上还有座位并预约座位
> 
> 5.代理人提供支付信息，结束预订
> 
> 6.系统预订座位并出票
> 
> __分支__
> 
> 4a.客户具备座位升级应具备的条件
>
>> 4a1.代理人请求为客户进行升级
>>
>> 4a2.系统验证在选择的航班上有可供升级的座位
>> 
>> 4a3.系统验证客户有进行升级的足够的升级优惠券
>> 
>> 4a4.系统将票的类别改为“已升级”
>>
>> 4a.__分支__
>>
>>> 4a2a.没有可供升级的座位
>>> 
>>>> 4a2a1.代理人将客户放在等待升级的清单上
>>>> 
>>>> 4a2a1.继续第4步的常规机票预订
>>>
>>> 4a3a.客户没有足够的升级优惠券
>>> 
>>>> 4a3a1.代理人为客户购买额外的升级优惠券
>
> 4b.在要求的票类中没有座位可以提供
>
>> 4b1.系统通知代理人在客户选择的票价类别中，没有座位可以提供
>>
>> 4b2.代理人指定另一种价格偏好
>
> 4c.没有座位可以提供（航班已满）
>
>> 4c1.系统通知代理人根本没有座位可以提供
>>
>> 4c2.代理人指定另一组起飞时间偏好

使用 __“包含”关系__ 提升了“升级座位”分支后的“预订航班”

> __预订航班__
> 
> 1.当代理人说明客户的旅行路线时，用例开始
> 
> 2.系统搜索一组符合条件的航班并将它们提供给代理人
> 
> 3.代理人“选择航班”
> 
> 4.系统验证航班上还有座位并预约座位
> 
> 5.代理人提供支付信息，结束预订
> 
> 6.系统预订座位并出票
> 
> __分支__
> 
> 4a.客户具备座位升级应具备的条件
>
>> 4a1.代理人请求为客户 __升级座位__
>
> 4b.在要求的票类中没有座位可以提供
>
>> 4b1.系统通知代理人在客户选择的票价类别中，没有座位可以提供
>>
>> 4b2.代理人指定另一种价格偏好
>
> 4c.没有座位可以提供（航班已满）
>
>> 4c1.系统通知代理人根本没有座位可以提供
>>
>> 4c2.代理人指定另一组起飞时间偏好

将“升级座位”作为单独的用例

> __升级座位__
> 
> 1.代理人请求为客户进行升级
> 
> 2.系统验证在选择的航班上有可供升级的座位
> 
> 3.系统验证客户有进行升级的足够的升级优惠券
> 
> 4.系统将票的类别改为“已升级”
>
> __分支__
>
> 2a.没有可供升级的座位
>
>> 2a1.代理人将客户放在等待升级的清单上
>
> 3a.客户没有足够的升级优惠券
>
>> 3a1.代理人为客户购买额外的升级优惠券

使用 __“扩展”关系__ 提升了“升级座位”分支后的“预订航班”

> __预订航班__
> 
> 1.当代理人说明客户的旅行路线时，用例开始
> 
> 2.系统搜索一组符合条件的航班并将它们提供给代理人
> 
> 3.代理人“选择航班”
> 
> 4.系统验证航班上还有座位并预约座位
> 
> 5.代理人提供支付信息，结束预订
> 
> 6.系统预订座位并出票
> 
> __分支__
>
> 4a.在要求的票类中没有座位可以提供
>
>> 4a1.系统通知代理人在客户选择的票价类别中，没有座位可以提供
>>
>> 4a2.代理人指定另一种价格偏好
>
> 4b.没有座位可以提供（航班已满）
>
>> 4b1.系统通知代理人根本没有座位可以提供
>>
>> 4b2.代理人指定另一组起飞时间偏好

基用例“预订航班”不引用扩展用例了，相反，扩展用例直接引用基用例，请注意下面的编号

> __升级座位__
> 
> __扩展“预订航班”__
> 
> 4c1.代理人请求为客户进行升级
> 
> 4c2.系统验证在选择的航班上有可供升级的座位
> 
> 4c3.系统验证客户有进行升级的足够的升级优惠券
> 
> 4c4.系统将票的类别改为“已升级”
>
> __分支__
>
> 4c2a.没有可供升级的座位
>
>> 4c2a1.代理人将客户放在等待升级的清单上
>
> 4c3a.客户没有足够的升级优惠券
>
>> 4c3a1.代理人为客户购买额外的升级优惠券

扩展用例有一个`VerbPhraseName`，它表示额外附加的功能，对于扩展用例来说，使得扩展多个基用例成为可能，如“升级座位”，也可以扩展“预订火车”用例，不过在扩展时，使用扩展点会更方便些

## CapuredAbstraction
将用例描述编写为`ScenarioPlusFragments`的形式，在一个用例中，试图把两个或多个不同的分支（任何一个都不占支配地位）编成文档是很困难的，而且容易引起混淆

有时一个用例有多个主要场景，每个场景都可以成为它自己的用例，但是，它们都填的是系统中的同一个洞，满足了相同参考者的相同目标，发生这种情况时，采取如下做法是有意义的：创建一个抽象用例，将参与者和目标编成文档，将每个主要场景放在它自己的用例中，然后使它们从抽象用例中继承

- 复杂或冗长的分支会搞乱用例，并且可能会模糊其他分支
- 一些问题非常复杂，而且有几个不同的解决方案
- 有许多单个的用例很可能会分散重要的行为，并且会使行为更难理解

__因此，__ 考虑创建一个泛化的抽象用例，将具体描述的这种抽象的每个不同的场景放在各自的特化用例中

在使用该模式时要小心，因为复杂的分支可能意味着过于详细或过大（`EverUnfoldingStory`，`LeveledSteps`，`CompleteSingleGoal`，`RedistributeTheWealth`），并且当`InterruptsAsExtensions`和`PromotedAlternative`无法解决时，才考虑使用抽象

编辑现有的用例
==============
在用例中应该一直注意“坏气味”，如用例过长，包含9步以上步骤的主成功场景可能说明用例或有多个目标，或包含过多的细节，应该使用`RedistributeTheWealth`，合理地将较大的用例划分为较小的内聚的用例

另一个“坏气味”是不能实现`CompleteSingleGoal`，因此仅为主参与者提供了`UserValuedTransactions`的一个片断

“坏气味”通常来源于CRUD格式的用例，或为GUI编写的用例

`RedistributeTheWealth`是拆分过分复杂用例，把它们独立分成可以独立存在的简单用例，`CleanHouse`消除那些不提供价值，或不能帮助我们了解参与者如何实现目标的用例

## RedistributeTheWealth
正在发现系统的`UserValuedTransactions`，过长的用例不实用而且难以使用，会分散用户的注意力，并使他们失去重点

- 用例的目标对涉众必须清晰
- 添加新用例的代价是昂贵的
- 过多的细节可能会使用例难以阅读和理解

__因此，__ 将冗长、难以处理的内容或过分复杂的扩展转移到它自己的用例中

重新组织的一些方式：

- 将片断重新放到其他用例中
- 创建一个新用例
- 创建一个新的较低层用例
- 将多余的片断重新定位到补充说明中

示例

> __拨打电话__
> 
> __主参与者__：主叫方－拨打电话的人；被叫方－接听电话的人
> 
> __次要参与者__：交换网－处理电话间呼叫的设备
> 
> __级别__：用户目标
> 
> __主成功场景__
> 
> 1.主叫方摘机
> 
> 2.主叫方拨号
> 
> 3.交换网转换数字符号，连接主叫方和被叫方的电话，并发送振铃信号
> 
> 4.被叫方应答（摘机）并与主叫方交谈
> 
> 5.被叫方和主叫方挂断电话
> 
> 6.交换网记录此次呼叫的计费信息，如果这是主叫方在当天拨打的第一个电话，那么，就会初始化客户文件中的日使用报告条目。如果是本地电话，它还把它记录在服务提供商的日志中。如果是长途电话，它把条目记录在相应长途电话提供商的日志中
> 
> 7.交换网切断连接，释放呼叫要求的所有组件
> 
> 8.交换网释放了在呼叫中使用的所有组件后，用例结束

上例违反了`CompleteSingleGoal`，它描述了两个单独的行为：拨打电话和计费，发现这种情况，可以创建一个新用例，也可以创建一个子用例，甚至做为`Adornments`。本例中，“记录计费信息”似乎实现了一个较低级的目标，因此，创建一个子用例比较合适（`EverUnfoldingStory`），应该：

- 从用例中提取话费记录信息，并用它创建新的子用例
- 修改“处理正常呼叫”用例，将引用新的子用例

子用例，注意参与者

> __记录计费信息__
> 
> __主参与者__：主叫方－拨打电话的人
> 
> __次要参与者__：交换网－处理电话间呼叫的设备
> 
> __级别__：用户目标
> 
> __主成功场景__
> 
> 1.交换网记录此次呼叫的计费信息，如果这是主叫方在当天拨打的第一个电话，那么，就会初始化客户文件中的日使用报告条目。如果是本地电话，它还把它记录在服务提供商的日志中。如果是长途电话，它把条目记录在相应长途电话提供商的日志中

引用子使用的基用例：

> __处理正常呼叫__
> 
> __主参与者__：主叫方－拨打电话的人；被叫方－接听电话的人
> 
> __次要参与者__：交换网－处理电话间呼叫的设备
> 
> __级别__：用户目标
> 
> __主成功场景__
> 
> 1.主叫方摘机
> 
> 2.主叫方拨号
> 
> 3.交换网转换数字符号，连接主叫方和被叫方的电话，并发送振铃信号
> 
> 4.被叫方应答（摘机）并与主叫方交谈
> 
> 5.被叫方和主叫方挂断电话
> 
> 6.交换网“记录计费信息”
> 
> 7.交换网切断连接，释放呼叫要求的所有组件
> 
> 8.交换网释放了在呼叫中使用的所有组件后，用例结束

## MergeDroplets
正在发现系统的`UserValuedTransactions`，描述细小或孤立的行为片断的用例不能传达足够的信息，来帮助读者理解系统如何提供`UserValuedTransactions`

- 不完整的用例不能讲述整个故事
- 最好是在任何可能的时候定位信息
- 最好使用例的数量最少
- 较小的用例易于理解和使用，每个用例应该都满足`CompleteSingleGoal`，没有不必要的细节或技术细节`TechnologyNeutral`

__因此，__ 将相关的小用例或用例片断合并到相同目标相关的用例中

合并用例不仅仅只是把几个步骤放到一起，因为最终得到的用例必须包含一个好用例所具备的模式，把步骤仔细编辑为描述`CompleteSingleGoal`的一个内聚单元，如果得到用例太大或太详细，对步骤精化，保持`ActorIntentAccomplished`，或对它们进行分级(`EverUnfoldingStory`，`LeveledSteps`)，很可能还需要仔细评审分支路径，删除一些路径并添加一些路径

示例，呼叫处理的一组小用例

> __主参与者__：主叫方－拨打电话的人；被叫方－接听电话的人
> 
> __次要参与者__：交换网－处理电话间呼叫的设备
> 
> __级别__：用户目标
> 
> __用例1：拨打电话__
> 
> __前置条件__：主叫方和被叫方的电话挂起
> 
> __成功保证__：系统收集了主叫方拨过的所有号码
> 
> __主路径__
> 
> 1.主叫方摘机时用例开始
> 
> 2.交换网发送拨号音
> 
> 3.主叫方拨号
> 
> 4.交换网转换数字符号
> 
> 5.交换网将呼叫连接到被叫方的电话上
> 
> 6.交换网向被叫方的电话发送振铃信号
> 
> 7.交换网向主叫方的接收器发送回铃信号，用例结束
> 
> __用例2：在电话中交谈__
> 
> __前置条件__：用例“拨打电话”向被叫方的电话发送振铃信号
> 
> __成功保证__：用户完成呼叫
> 
> __主路径__
> 
> 1.被叫方的电话响后，用例开始
> 
> 2.被叫方应答（摘机）
> 
> 3.交换网完成主叫方和被叫方之间的连接
> 
> 4.被叫方和主叫方通话
> 
> 5.被叫方和主叫方挂断电话，用例结束
> 
> __用例3：结束呼叫__
> 
> __前置条件__：通过“在电话中交谈”连接呼叫
> 
> __成功保证__：交换网切断了呼叫，所有组件都恢复了呼叫前所处的状态
> 
> __主路径__
> 
> 1.主叫方和被叫方挂断电话时用例开始
> 
> 2.交换网释放在呼叫中使用的所有组件
> 
> 3.交换网“记录计费信息”，用例结束

这种方式来编写程序不错，但不适用于用例，就修改上上一章节中的形式

对于读者来说包含了拨号、通话和结束电话呼叫的场景的用例才是有意义的，无需通过阅读几个用例来发现关于该行为的必要信息

## CleanHouse
正在发现系统的`UserValuedTransactions`，以于整体没有什么价值的用例是分散注意力的，并可能会使读者误入歧途

不需要的用例没有什么价值，只会造成混乱，将注意力从系统的主要目标上转移开

- 清除已有的用例会占用时间和精力
- 未使用的用例搞乱了工作空间，并且会浪费精力
- 去掉用例避免了大量的开发工作，并节约了精力


__因此，__ 删除不会为系统添加任何价值，或者已经不在现有用例清单中的那些用例

确定了某些用例不再为系统提供任何价值后，把它们从集合中删除，可以将觉得有用的用例作为`Adornments`，但要立刻停止编写这些用例





















































































































































































































































