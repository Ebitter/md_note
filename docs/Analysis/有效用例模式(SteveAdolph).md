> 2014-09-06

<!-- 
`Adornments`
`TechnologyNeutral`
`CompleteSingleGoal`
`LeveledSteps`
`ExhaustiveAlternatives`
`ActorIntentAccomplished`
`UserValuedTransactions`
`SharedClearVision`
`ClearCastOfCharacters`
`PreciseAndReadable`
`BalancedTeam`
`ParticipatingAudience`
`SmallWritingTeam`
`BreadthBeforeDepth`
`SpiralDevelopment`
`TwoTierReview`
`QuittingTime`
`WritersLicense`
`MultipleForms`
`RedistributeTheWealth`
`MergeDroplets`
`CleanHouse`
`VisibleBoundary`
`EverUnfoldingStory`
`VerbPhraseName`
`ScenarioPlusFragments`
`DetectableConditions`
`ForwardProgress`
`CommonSubBehavior`
`InterruptsAsExtensions`
`PromotedAlternative`
`CapuredAbstraction`


 -->



概述
========
早些年，没有人能清楚说出一个用例与场景的区别，但那些想法却保留了下来：书写短小的、基于文本、关于系统如何与周围事物交互的叙述，这些交互为用提供一个价值，同时捕获出现错误时的系统行为

在形成不同流派中，几乎是下列问题的排列组合

- 一个用例是一项需求还是只是一个故事？
- 场景是否只是用例的另一个名字？（Martin Fowler认为是）
- 用例的结构是形式的、非形式的、还是半形式的？
- 用例是否有关联结构，还只是堆在一起？

我们选择是一条中间路线，半形式的结构中的半形式文本：

- 断言用例确实是需求并且需要一个基本结构，同时，
- 允许人们在需要的时候书写任何想写的东西（更重要）

## 使用目标组织用例
用例描述了一个参与者试图使用系统达到一个目标，将 __*注意力*__ 从功能列表转移到 __*用户身上*__ ：用户真正需要使用这个软件来完成什么是他们使用这个软件的目标，如果软件支持这些目标，软件将产生最大的商业 __*价值*__

目标有时会失败，__*思考*__ 并写出需求文档中 __*失败处理*__，能够在项目过程中为设计团队节省 __*成本*__

因此一个用例的结构分为两部分，每件事都顺利进行时事件序列，随后是各个目标和子目标失败时的不同小事件序列的描述

甚至可以说，用例的最大价值不在于主场景，而在于备选行为

## 加入涉众和利益
为什么我们要在用例中书写外部不可见的行为？如在给钱之前记录“银行检查客户余额”

计算机的动作 __加强了 *涉众之间* 的契约__，每一个动作既是为了维护这个涉众的利益，也是为了维护其他涉众的利益

Jim走向糖果机，他的目的不是花钱，真实目的是想吃糖，如果糖是免费的，他会更高兴。糖果机的主人立场相反，他的目的不是为了发放糖果，如果人们只往机器放钱而不要糖，他也会更高兴。糖果机加强了一个简单的契约：Jim放入钱，机器的主要看着他得到糖果

在保险业务的相关契约中更加复杂：受益人提出索赔；保险公司在允许的范围内付出最少金钱；保险部门检查事务的操作在政策之内。

__涉众和利益模型__ 填补了 __参与者和目标模型__ 的空白。系统接受消息，根据业务规则验证输入值，更新内部状态或输出数据，它的每一个动作和涉众利益相关，主参与者和辅助参与者都照顾到了

## 反对用例的声音
这些人认为用例是非形式、非结构化，不是需求，而通过：特征列表（feature lists）、故事卡片（story cards）、task cases等技术

## 用例的局限
用例不关心系统设计、界面设计、特性列表或测试，即使许多人想这么做

高质量的用例
===========
## 为什么要使用用例
- 首先，用例提供了一种基于构建故事的半形式化框架，参与者和用例，以及它们间的通信规则，不足以讲述一个故事，故事必须有一个目的。用Ivar Jscobson的话说，“为系统内的单个参与者产生一个有可度量价值的结果”
- 其次，在每个用例和所有描述层次中，用例都描述了错误情况的系统需求
- 再次，虽然用例本质上是一种功能分解技术，但它们已经成为面向对象软件开发的一个流行元素
- 最后，用例提供了可以在其上处理其他项目信息的骨架：
    - 项目经理可以根据用例进行估计和发布进度；
    - 数据及业务规则制定人员可以把自己的需求和所需用例联系起来；
    - 界面设计人员可以进行设计，并将其与相关用例联系起来；
    - 测试人员可以根据用例中描述的成功和失败情况构建测试场景。

## 讲述好故事的困难
- 用户界面细节太多，通常发现对鼠标点击、列表框和窗口设计的引用，用户界面设计细节通常不是需求，它们一般是设计选择，在编写并评审了用例之后，才需要做出设计选择，`Adornments`模式和`TechnologyNeutral`模式阐述如何避免过多的细节
- 较低目标层次上的用例太多，程序员经常会在“验证用户身份”这类层次上生成大量低层次用例，很大程度是因为这些功能必须实现，但这样编写的需求文档就很长，难以阅读，也无法展示系统给最终用户和客户提供什么功能。`CompleteSingleGoal`模式讲述了如何适当地构建用例，避免这类问题
- 使用用例表示非行为信息。其实用例只适用于描述行为，有些人员用非常详细的用例描述用户界面表单的完成。最好是创建一个`Adornment`，将性能需求、复杂的业务规则、数据结构等放入
- 太冗长，较好的用例通常为3~9步，`LeveledSteps`模式讲述如何编写均衡、大小适度的用例
- 目标实现不完整，编写人员没有捕获目标实现的全部行为，而只是描述了所必需行为的一个片断。由于用例间没有联系，程序员只能猜测如何将它们连在一起，没有考虑所有故障情况或可选行为。`CompleteSingleGoal`模式和`ExhaustiveAlternatives`模式就如何把目标和用例联系起来，以及如何包括所有必须的失败情况给出了建议
- 句子片断，一个相对较小但也要注意的错误是不要用句子片断编写用例。如果在操作步骤中省略了参与者名称，就很容易导致项目过程混乱。`ActorIntentAccomplished`模式讲述了如何编写步骤清晰且无二义性的场景

## 一个示例
> 登记课程
> 
> 1. 学生请求提供一张新课程表
> 
> 2. 系统准备好空白的课程表表格，从“课程分类系统”中抽取已开设和可选的课程列表
> 
> 3. 学生从系统提供的上述课程中选择主修课程和选修课程
> 
> 4. 对选中的每门课程，系统确认学生已学习了必需要前导课程，然后把学生添加至该课程中，并在课程表中标记学生“已登记”该课程
> 
> 5. 学生说明课程已填好之后，系统保存课程表

## 用例模式表格
- __模式名称__
    + 强调所建议解决方案的共性的名词短语。
    + 如`UserValuedTransactions`这个名称让人觉得该服务是对某个人是有价值的
- __一张图片__
    + 为模式提供一个形象的比喻。
    + 如`UserValuedTransactions`的形象比喻是排队准备为赛马下注的人，他们愿意排队付款，说明他们认为这一行动是值得的
- __上下文__
    + 问题发生的条件，描述了限制模式和解决方案适用场合的边界，还描述了该模式如何与语言中其他模式相关，并指出了哪些模式是该模式的先决条件。
    + 如`UserValuedTransactions`的上下文是：已经建立了项目的`SharedClearVision`，并定义了需要系统提供服务的`ClearCastOfCharacters`
- __问题陈述__
    + 由一两个句子组成，这些句子描述了当用例不能满足一定的标准时会发生什么情况，这些陈述还反映了 __不遵照该标准带来的风险__。
    + 如`UserValuedTransactions`的问题陈述为：如果系统不能对用户提供有价值的服务，并且不支持系统愿意规定的目的和目标，那么，该系统就是不完善的
- __隐喻故事__
    + 提供隐喻故事，以使模式更易于理解
- __影响问题的约束__
    + 概述了影响问题的各种因素，以及在使解决方案复杂化和约束解决方案的各种因素之间的权衡，这部分描述了编写者必须对所面对的具体情况作出重要权衡
    + 如`UserValuedTransactions`，我们需要平衡的约束：
        * 一组用例应该捕获用户和涉众需要系统提供的基本增值服务
        * 识别低层事务相对较为容易，但识别有用的服务可能就难了
        * 用例需要相对稳定，因为它们形成了产品开发过程其他部分的“定位点”
        * 读者希望容易看到系统如何满足其目标（请看`SharedClearVision`）
        * 人们有一种太高或太低的层次上工作的倾向
- __解决方案__
    + 该解决方案是平衡了相互竞争的约束，并反映了编写良好的用例的特征
    + 如`UserValuedTransactions`的基本解决方案是：识别系统为参与者提供以满足其业务目的的有价值服务
- __示例__
    + 每个模式都有一个或多个示例，证明实现模式所建议的解决方案的好处，或不这样做的后果

## 模式语言的组织
31个模式分两大类：开发模式和结构模式

### 开发模式
描述了已经过验证的用例编写实践的特征，并提供了度量编写过程质量的准测

- __团队组织__：判断和改进用例团队组织方式的质量的模式
    + 团队的人员的变化是一个重要但经常被忽视的方面。在对所得到用例的影响方面，编写人员之间的个人交互与用于识别编写用例的技术造成的影响不相上下
    + 编写`PreciseAndReadable`用例要求有一个`BalancedTeam`和一个`ParticipatingAudience`。赞助者、开发人员、交互专家和领域专家都参与这项工作并对它进行评审。然而编写人员太多反而会把问题搞砸，任何一个编写任务都应该使用一个`SmallWritingTeam`
- __过程__：判断和改进团队用来创建用例的方法质量的模式
    + 遵循一个好的过程对于编写高质量的用例非常关键，该过程不一定很讲究或很强大，但一定要包括所有基本成分。好的过程意味着平衡发现和编写，用足够内容对系统进行充分描述，不返工，不做多余工作，以使开发人员能够开始构建系统
    + 尽管不提倡创建用例的任何具体过程，但高效的团队都使用`BreadthBeforeDepth`，部分扩展一些用例之前，首先命名许多用例，在考虑失败处理之前完成主成功场景，并实现用例集的`SpiralDevelopment`
    + `SmallWritingTeam`将它的工作与`TwoTierReview`集成在一起，其中，具有不同专长的核心工作人员先对工作进行评审和调整，然后才将其交给包括有涉众代表的团队
    + 有效的团队知道什么时候是`QuittingTime`，团队成员不会长时间争论一个肤浅的问题，而是允许一定数量的`WritersLicense`，他们认识到强迫所有人员使用一致的编写习惯或不太得要的标准很快就会使这项工作不再增加价值
    + 并不是每个项目团队都需要相同数量的细节来完成其任务，用例的`MultipleForms`是需要的，也可将每个格式用到同一个项目的不同时段上
- __编辑__：随着潜在需求的变化和编写人员知识的增加，判断和改进单个用例质量的模式
    + 因为潜在的需求非常不稳定且容易发生变化，因此，用例可能很快就会过时，随着对系统深入理解，它会发生变化，通过调查与客户交谈，可以加深对系统的了解。
    + 在编写过程中，组员会定期发现他们编写的用例要么大而复杂、难以阅读，要么小、不重要。应该将大的用例`RedistributeTheWealth`分成较小的用例，并太小的用例`MergeDroplets`合并到其他用例中。最终，他们可能会发现一些用例完全无关的，为了处理这些用例，可以`CleanHouse`

### 结构模式
描述了用例的基本组成部分，解释了应该如何对其进行组织，并提供了判断其使用的准测

- __用例集__：判断和改进用例集质量的模式
    + 用例集是用例和相关信息的集合，它以一种便于使用的方式组织为用例模型，包括产品的系统级信息，包括参与者、边界以及成员用例之间的关系，这一级别主要是组织级的，描述是集合的关键特性而非具体行为。在这一级别工作的人们通常根据名字引用单个用例，忽视它们的内容
    + 用例集最重要事情是，应该清晰的`VisibleBoundary`来反映系统的`SharedClearVision`。用例共同组织为较高层的用例，这些高层用例从`EverUnfoldingStory`中引用低层用例，`EverUnfoldingStory`则展示了`ClearCastOfCharacters`，它们与系统交互来实现它们的目标。尽管在各个级别上都有描述的目标，但最关键和有兴趣的目标描述的是`UserValuedTransactions`。
- __用例__：判断和改进单个用例质量的模式
    + 单个用例描述对`CompleteSingleGoal`的追求，它应该有一个描述性的`VerbPhraseName`来让读者了解它的意图，每个用例都对可以实现它的多种方式，成功的、不成功的，用一个描述在不同条件下将会发生什么情况的场景片断集合，组织成`ScenarioPlusFragments`，一个完整的用例考虑`ExhaustiveAlternatives`
    + 为了使赞助者、用户和开发人员满意，编写人员要力争使用例`PreciseAndReadable`，这是用例编写的一种技巧，同时也是一种可实现的目标，从用例文本中消除性能需求、数据格式以及用户界面，用文档分离它们，作为`Adornments`
- __场景和步骤__：判断和改进用例场景以及这些场景中的步骤质量的模式
    + 场景描述了用例中一个完整的事件序列。主成功场景后的每个场景片断都描述了参与者在某些`DetectableConditions`下的行为（对讨论中的系统来说是可检测的）。良好用例的可读性部分是`LeveledSteps`，它使所有的步骤都保持在大致相同的详细级别上
    + 每个步骤都应该使不同的`ForwardProgress`靠近目标。由于用户界面细节和其他设计决策作为`Adornments`出现的，因此能够用`TechnologyNeutral`方式详尽编写每一个步骤，最后，每一个步骤都应该使`ActorIntentAccomplished`，读者总能说出谁在做什么
- __用例关系__：判断和改进集合中用例之间的结构关系质量的模式
    + Ivar Jscobson定义了 __“包含”、“泛化”、“扩展”__ 的概念
    + 当一组共有的动作在几个用例中再次出现时，最简单和最自然的联系就是把`CommonSubBehavior`移到由其他用例通过“包含”关系引用的子用例中。
    + 当单个事件可能多次中断用例流时，编写人员就应该把那些中断编成扩展（`InterruptsAsExtensions`）
    + 如果一个给定的分支开始支配用例，那么，应该考虑把分支提升为扩展用例，即`PromotedAlternative`
    + `CapuredAbstraction`建议何时使用泛化


团队
======
## 团队的组织问题
每个用例编写团队都应该是一个`SmallWritingTeam`，其中，任何用例的编写人员数量都应该限制为2或3人，以避免低效或由团体设计用例

在保持用例编写组织规模较小的同时，还应让尽可能多的涉众参与编写过程，以确保用例满足所有涉众的需要，`ParticipatingAudience`解决了管理团队规模中相互冲突的问题

团队的构成是影响用例质量的另一个因素，有效的团队是`BalancedTeam`，由具有不同技能、专业知识甚至个性的人组成的

## SmallWritingTeam
有一个系统的`SharedClearVision`，正在组织人员来编写用例。

用太多的人编写用例是低效的，为了统一不同的观点所做的折衷可能会导致开发出来的系统不太令人满意

- 用例要求具有不同观点和专业知识的人编写
- 将大组人聚集在一起是困难的
- 理论上，在用例上投入的人力越从，就能越快的完成用例编写工作，但超出了足够人员时，事情会变糟
- 太大的团队会变得低效
- 大型编写团队可能会通过集体讨论的形式开发用例，添加许多不必要的特性

因此，将精化任何一项制品的人员数量限制为2或3个，使用`TwoTierReview`过程包括更多的参与人员

同时，尽量表现每个小组的不同观点，创建`BalancedTeam`，选用具有不同背景、技能和个性的人员，以使团队不会用相同的方法看待用例

使用`ParticipatingAudience`和`TwoTierReview`使更多的人参与到过程中，提高人的参与程度，同时避免使用大型编写团队

## ParticipatingAudience
正在创建用例的一个`SmallWritingTeam`，没能涉众提供信息和反馈，就不能满足他们的需要

- 许多不同的小组对同一组用例有着不同的兴趣
- 如果客户不喜欢开发出来的产品，他们就不会购买
- 在用例开发过程中包括所有目标读者通常是不切实际的
- 开发组织并不能充分代表最终用户

因此，尽可能使客户和内部涉众积极参与用例开发过程

可通过评审很好的与客户共享用例，充分利用客户时间，组织良好的`TwoTierReview`更是如此，通过评审与那些平时无法接近的客户和用户交流

## BalancedTeam
正在组织`SmallWritingTeam`来编写用例，由一些个性相似、意见相同的个人组成的团队开发用例，可能会得到一组缺乏创见、范围狭窄的用例，这种用例不能满足每个人的需要

- 由技术背景相同的人员组成的小组很可能会把注意力放在相同的、狭窄的问题上
- 每个专业都使用其专用词汇，该专业以外的人不能理解这些词汇
- 在不同的时期，开发团队需要不同的专业知识
- 出色的小组是平衡的，这样，每个人的专长都可以弥补其他人的弱点

因此，为小组配备具有不同专长的人员，以维护开发过程中涉众的利益，确保团队中包括开发人员和最终用户

过程
=======
尽管没有创建用例的通用过程，但还是有一些通用元素，这些模式并不构成一个过程，它们之间没有一定的顺序，而是陈述一些有关过程的事实。

一个有效的过程以一种`BreadthBeforeDepth`的方式创建用例，在对其进行描述前识别潜在的用例，以一种可控的方式添加细节，并实现用例集的`SpiralDevelopment`，在开发用例时，人们所犯一个最大错误就是按顺序编写，容易耽搁在难以开发的用例上，或在随后用例开发中发现需要重新编写已完成的用例

一个有效的过程能够使编写人员从`MultipleForms`中进行选择，并确定适当的详细级别

传统评审过程通常是低效的，他们可以要求一个大的、由具有相互竞争需要的评审人员组成的多样性小组。为了避开这一问题，`TwoTierReview`描述了如何进行评审，描述了内部评审和紧接其后的外部评审，对于那些趋于完整的用例，在将其提交给更大的小组来从系统的角度对其进行评审前，要先对它们进行正确性和完整性评审

有效的团队知道什么时候是`QuittingTime`，他们不会在不太重要的问题上争论不休，而是允许一定数量的`WritersLicense`，他们认识到强迫所有人员使用一致的编写习惯或不太得要的标准很快就会使这项工作不再增加价值

## BreadthBeforeDepth
已经有了`SharedClearVision`和`ClearCastOfCharacters`，并开始编写有例，如果浪费精力按顺序编写详细用例，就不会及时取得进展或创建一致的用例集

- 需求收集是一个发现的过程
- 人们很早就开始编写用例的细节
- 人们浪费了精力或陷入了太多的细节中
- 在早期获得概述是有益的
- 最初编写的细节越多，在了解系统后必须进行的改变也就越多

因此，通过首先开发用例的概述来保存精力，然后逐步增加细节，并行开发一组相关用例

开始编写用例时，在添加细节前先对其进行概述，通过为每个参与者关联一个有意义的目标来识别候选的用例，为每个参与者－目标组合定义一个用例（`UserValuedTransactions`）。使用目标为每个用例导出一个`VerbPhraseName`。一旦觉得已经定义了一个 __相当完整的用例集__，就开发这一组用例，对其进行精化，将等效的用例组合在一起，并消除不必要的用例(`RedistributeTheWealth`，`MergeDroplets`，`CleanHouse`)。所得到的系统目标集合为涉众提供了基本的、共有的理解，并帮助减少了后来需要的重构工作

避免突然开发完所有用例或一次只开发一个用例的倾向，要以一系列`SpiralDevelopment`周期的形式开发用例，渐进地添加细节，评审新细节对模型的影响，直到确定已到了`QuittingTime`

通过描述每个用例的主成功场景，指定可能发生的各种情况，充实一些更重要的用例，将用例扩展为`ScenarioPlusFragments`。从集合中消除不重要部分时要果断，向片断中添加更多的细节时，在下一个周期中创建一个`ExhaustiveAlternatives`

当进行渐进开发时，模坂可以作为能够使编写人员在遗漏大段内容的情况下编写用例的占位符。使用`MultipleForms`，将适当的详细级别和精度将每个用例编成文档

有时，确实也需要为用例划分优先级

## SpiralDevelopment
正在用`BreadthBeforeDepth`方式编写用例，用“一次通过”的方式开发用例是困难的，并且会将新增信息集成到用例中变得昂贵。更糟糕的是，它可能会拖延发现风险因素的时间

如果发现用例并没有带来预期的结果，我们可以轻松地回去，抛弃它们或者重新编写。使用迭代的方法可以使我们更快地识别和面对潜在的问题

- 理解系统的行为可能会花掉的时间
- 拖延是昂贵的，需要尽快的完成用例的编写
- 对需要进行分析后，需求很可能会发生变化（分析需求就很可能会改变需求）
- 需求错误的成本是昂贵的
- 如果工作进展得太快，就会使人感到不堪重负

因此，用一种迭代的、宽度优先的方式开发用例，每次迭代都会逐渐提高用例集的准确性和精度

按照`BreadthBeforeDepth`的模式，当列出了参与者和它们的目标时暂停一下，暂时使用该列表进行其他工作：制定项目计划，对工作进行估计并划分用例价值的优先级，甚至使用它帮助组建开发团队

继续按`BreadthBeforeDepth`的模式开发用例，选择用例的一个工作子集进行扩展，当有了一组主成功场景后再次暂停一下，评审系统的目的。此时，抓住机会对用例进行评审。看看是否需要`MergeDroplets`或`CleanHouse`，或用任何其他方式改进结构，可能会发现自己修改了参与者和目标的列表

当开始找出用例的扩展处理时，可能会发现自己再一次修改了用例列表，通常会出现新用例

`SpiralDevelopment`与`BreadthBeforeDepth`交互，`SpiralDevelopment`建议编写团队暂停并重新对用例分组

成功使用迭代开发的关键是，知道如何控制在评审中投入的精力，以及在什么时候应该停下来，使用`TwoTierReview`，并在只要自己确信用例已足够好，能够满足涉众的需要时就停下来

示例，首先从简单的东西开始，仅列举参与者以及他们使用的用例名称，一旦编写人员完成了列表，可以尝试编写简单的，仅有一个段落的故事，来描述用例的主成功场景，通常被称为“概要”或“高层用例”

> 预约航班
> 
> 参与者：代理人
> 
> 代理人详细说明客户要求的旅行路线，系统搜索合适的飞行路线并将其提供给代理人。代理人选择一个最佳满足客户要求的路线。系统验证有座位，然后预约座位。系统计算代理人所请求的服务类别的机票价格

__摘要并不叙述详细的步骤、分支、前置条件和后置条件，相反，它们的目的是在深入讨论细节之前，快速包含系统的主要范围－宽度__

## MultipleForms
正在使用`SharedClearVision`，不同项目需要不同程度的形式化，每个人对模板都有不同的偏好，要求每个人都使用相同的用例模板只会起到相反作用

- 人和项目都是不同的，每个人都是独一无二的，都有自己看待问题的方式
- 不同的项目有不同的需要，可大可小，可简单可复杂
- 不同的编写团队需要不同程度的规范
- 在组织中使用公共的编写形式有助于交流

尽管模板有用，但一口气填充完所有的模板，可能会耗尽精力，并失去重点

因此，根据与项目相关的风险以及所涉及人员的偏好选择用例编写格式

选择用例格式时，要能接受新思想，不要陷入所有用例看起来都应该相同的惯例中，根据用例目的以及与每个用例相关的风险级别选择模板，对于关键用例，编写包含大量丰富信息的更加形式化的用例，并密切关注`ExhaustiveAlternatives`和`PreciseAndReadable`，对于不太关键或理解较好的用例，不要太形式化并使用较少的细节

对于一个编写小组来说，很难使用多个模板完成用例的编写，应选择一个标准的模板，然后一直使用下去，该模板有助于编写团队处理用例集的`SpiralDevelopment`

## TwoTierReview
正在用一系列的`SpiralDevelopment`编写用例，许多人可能需要评审用例，这是一件昂贵耗时的事情

- 对于验证和确认编写及内容来说，评审是必要的
- 涉众在用例中有一种既得利益
- 使每个人参与编写过程非常昂贵、麻烦并且缓慢
- 如果仅由一个小的编写组进行评审，就不会考虑所有涉众利益
- 评审可能是昂贵、乏味和耗时的

因此，进行两种类型的评审：第一种由较小的内部小组进行的评审，可能重复进行很多次；第二种是由整个团队进行的评审，可能只进行一次

内部评审，以验证其可读性、实现性、精度和准确性，可以是非正式的集体评审，当系统过大或复杂时，可能需要进行几次这样的内部评审

内部评审结束后，小组提出`QuittingTime`，认为用例是完整、正确的，达到应该达到的可实现性，然后，更大的团队将检查这些用例

外部评审的目的：

- 这真的是开发人员要花时间构建的适当产品吗？（业务价值检查）
- 这作为规格说明正确吗？（业务规则正确吗？它是否为实现预留了允许的适当变化？它是否遗漏了重要的决策？它是否识别了可在以后处理的适当的保留问题集？）
- 开发人员真的能够构建吗？

## QuittingTime
用`BreadthBeforeDepth`方式编写了一组用例，开发一个超出了涉众和开发人员需要的用例模型不仅浪费资源，而且会拖延项目进度

知道什么时候停止编写用例可能是困难的，因为确定什么时候停止涉及到一些复杂因素的平衡

- 忽视重要需求的巨大恐惧使构建人员和涉众延长了需求收集活动
- 许多技术专业人员给了模型的形式一个没有根据的高优先级
- 模糊可以对项目造成破坏
- 大多数人都可以用一种合理模糊性工作
- 对需求的过多说明可能会使涉众相信需求的表述非常精确
- 如果及早发现错误，其成本还是很低的，但停止不前的成本通常是很高的

因此，在用例完整并且符合参与者的需要后，停止开发用例

为了确定用例是否已经完整：

- 是否识别了所有的参与者和目标并将其编成了文档？
- 客户或代表客户的其他人是否承认用例集是完整的，而且每个用例都是可读的和正确的？
- 设计人员能够实现这些用例吗？

不要太担心质量，要避免过多关注表面上的东西，超过临界值后，进一步开发用例不会增加对系统的任何理解

## WritersLicense
正在对用例进行`TwoTierReview`，并且怀疑是否到了`QuittingTime`，过分强调格式问题不必要的阻止了编写用例的工作

- 我们喜欢一个一致的编写格式，以简化阅读
- 让每个人都用完全相同的格式编写用例不仅代价很高，而且不切实际
- __尽早使用例进入开发阶段是有价值的__
- 仍然需要满足用例的基本完成准则：可读、逻辑上正确以及对开发人员足够详细

因此，编写格式上的细微差别是不可避免的，一旦用例通过了`QuittingTime`测试，编写人员就可以要求得到细微格式差别的"编写人员许可证"

编写每个用例，使其通过如下测试：

- 它遵循组织的编写模板和基本格式
- 它逻辑上是正确的
- 对最终评估人员来说，它是可读的
- 对实现人员来说它足够精确，可以使用

90%的用例前置条件都提供了"用户已登录"，尽管可能是有效的，但增加价值了吗？


用例集
========
对于系统中应该包括什么和不包括什么（更重要），每个人似乎都有自己的看法

缺乏清晰的边界所导致的结果是，参与者无处不在，好像只是看到了职位描述，就宣布他们为参与者，编写的用例名为

> 订票人：寻找航班
> 
> 代理人：寻找航班
> 
> 顾问：寻找航班

其他用例则使用CRUD来定义：

> 参与者创建数据
> 
> 参与者阅读数据
> 
> 参与者更新数据
> 
> 参与者删除数据

用例集模式是编写良好的 __一组__ 用例质量标志，不直接归因为某一个用例，它们描述了所有用例自然出现的属性

首先，对于系统的目的和目标，用例编写人员必须有一个`SharedClearVision`，为什么构建该系统？所有都知道并具有相同的愿景吗？对愿景的需要超出了用例的范围，因为如果项目参与人员不明确系统的目的，很可能会不恰当的假定一个目的

必须用一个限制系统范围的`VisibleBoundary`来限制愿景。该边界清晰的描述了什么属于系统，什么不属于系统。系统的责任是什么？哪些人以及其他哪些系统将与该系统交互？

`VisibleBoundary`有助于我们发现谁或什么能够与系统交互，谁在外部请求系统提供服务，以及谁在外部帮助系统提供这些服务，这些参与者是`ClearCastOfCharacters`。参与者包括人、组织、计算机系统或硬件

如果系统要实现`SharedClearVision`中规定的目的和目标，它必须为参与者提供什么服务？这些服务是`UserValuedTransactions`，它们为系统的参与者产生可测量的价值

我们将用例的结构组织为较高层的用例引用`EverUnfoldingStory`中较低层用例的形式。这种组织方式能够使读者在各种层次的细节上（取决于他们的需要）都把重点放在系统上

## SharedClearVision
认为编写一组用例将帮助涉众理解系统的功能需求，缺乏一个清晰的系统愿意可能会导致优柔寡断，涉众之间不能达成一致意见，并可能很快就使项目瘫痪

高效的用例编写人员对系统目的有一个清晰的愿景，并且确信参与系统开发的每个人都共享这一愿景

- 时间压力可能会使人过早地开发系统，他们的工作建立在错误假设的基础之上，使其步入正轨的代价可能会非常昂贵，构建人员只是列举系统的基本服务，创建用例时并不理解这些用例对要求提供服务的参与者的价值，许多CRUD用例都是构建时没有一个清晰的愿景所导致
- 构建人员有一种扩展系统范围的自然倾向
- 涉众之间有一些相互冲突的愿景
- 与外界隔离的人不知道项目的目标是什么
- 人员之间不进行交流

因此，准备一份清晰描述系统目标的系统目的陈述，确保其支持组织的使命，并将其直接分发给参与项目的每个人

愿景陈述中包括：

- 系统目标
- 系统将解决的问题
- 系统不会解决的问题
- 涉众是谁
- 系统将如何使涉众受益

该责任通常由某个营销人员承担，如产品经理，他还必须积极的与开发团队所有人员沟通，以确保他们对系统愿景具有相同的解释

通过获得那些将受系统影响的人的建议，验证系统愿景并寻求对该愿景的支持（`ParticipatingAudience`）

通过明确规定什么属于系统以及什么不属于系统，可以增强和限制系统愿景（`VisibleBoundary`，`ClearCastOfCharacters`）

确保愿景支持涉众的任务，并且出现在`UserValuedTransactions`中

最后，当系统愿景发生变化时，要确保所有的项目参与人员都能及时获悉这些变化

## VisibleBoundary
拥有系统的一个`SharedClearVision`，如果不知道系统的边界，系统的范围就会以一种不可控制的方式增长

- 对于系统的边界，不同的人有不同的观点
- 定义糟糕的边界会导致范围的蠕变
- 在项目初期，不准确的和相互冲突的目标通常导致确定系统的边界变化得难
- 人们认为定义边界是不必要的

因此，通过列举与系统交互的人员和设备，在系统与其环境之间建立一个可见的边界

`VisibleBoundary`通过以下方式限制和支持`SharedClearVision`：

- 指定系统必须与之协作的外部系统和人员，建立一个`ClearCastOfCharacters`
- 指定系统为完成其目的应该拥有的资源

在开发早期，系统愿景并不清晰，边界可能是模糊的，但随着用例的开发和对系统了解的加深，可以对系统边界进行求精和深化，进行`SpiralDevelopment`

## ClearCastOfCharacters



