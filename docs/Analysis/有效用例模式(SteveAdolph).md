> 2014-09-06

<!-- 
`Adornments`
`TechnologyNeutral`
`CompleteSingleGoal`
`LeveledSteps`
`ExhaustiveAlternatives`
`ActorIntentAccomplished`
`UserValuedTransactions`
`SharedClearVision`
`ClearCastOfCharacters`
`PreciseAndReadable`
`BalancedTeam`
`ParticipatingAudience`
`SmallWritingTeam`
`BreadthBeforeDepth`
`SpiralDevelopment`
`TwoTierReview`
`QuittingTime`
`WritersLicense`
`MultipleForms`
`RedistributeTheWealth`
`MergeDroplets`
`CleanHouse`
`VisibleBoundary`
`EverUnfoldingStory`
`VerbPhraseName`
`ScenarioPlusFragments`
`DetectableConditions`
`ForwardProgress`
`CommonSubBehavior`
`InterruptsAsExtensions`
`PromotedAlternative`
`CapuredAbstraction`


 -->



概述
========
早些年，没有人能清楚说出一个用例与场景的区别，但那些想法却保留了下来：书写短小的、基于文本、关于系统如何与周围事物交互的叙述，这些交互为用提供一个价值，同时捕获出现错误时的系统行为

在形成不同流派中，几乎是下列问题的排列组合

- 一个用例是一项需求还是只是一个故事？
- 场景是否只是用例的另一个名字？（Martin Fowler认为是）
- 用例的结构是形式的、非形式的、还是半形式的？
- 用例是否有关联结构，还只是堆在一起？

我们选择是一条中间路线，半形式的结构中的半形式文本：

- 断言用例确实是需求并且需要一个基本结构，同时，
- 允许人们在需要的时候书写任何想写的东西（更重要）

## 使用目标组织用例
用例描述了一个参与者试图使用系统达到一个目标，将 __*注意力*__ 从功能列表转移到 __*用户身上*__ ：用户真正需要使用这个软件来完成什么是他们使用这个软件的目标，如果软件支持这些目标，软件将产生最大的商业 __*价值*__

目标有时会失败，__*思考*__ 并写出需求文档中 __*失败处理*__，能够在项目过程中为设计团队节省 __*成本*__

因此一个用例的结构分为两部分，每件事都顺利进行时事件序列，随后是各个目标和子目标失败时的不同小事件序列的描述

甚至可以说，用例的最大价值不在于主场景，而在于备选行为

## 加入涉众和利益
为什么我们要在用例中书写外部不可见的行为？如在给钱之前记录“银行检查客户余额”

计算机的动作 __加强了 *涉众之间* 的契约__，每一个动作既是为了维护这个涉众的利益，也是为了维护其他涉众的利益

Jim走向糖果机，他的目的不是花钱，真实目的是想吃糖，如果糖是免费的，他会更高兴。糖果机的主人立场相反，他的目的不是为了发放糖果，如果人们只往机器放钱而不要糖，他也会更高兴。糖果机加强了一个简单的契约：Jim放入钱，机器的主要看着他得到糖果

在保险业务的相关契约中更加复杂：受益人提出索赔；保险公司在允许的范围内付出最少金钱；保险部门检查事务的操作在政策之内。

__涉众和利益模型__ 填补了 __参与者和目标模型__ 的空白。系统接受消息，根据业务规则验证输入值，更新内部状态或输出数据，它的每一个动作和涉众利益相关，主参与者和辅助参与者都照顾到了

## 反对用例的声音
这些人认为用例是非形式、非结构化，不是需求，而通过：特征列表（feature lists）、故事卡片（story cards）、task cases等技术

## 用例的局限
用例不关心系统设计、界面设计、特性列表或测试，即使许多人想这么做

高质量的用例
===========
## 为什么要使用用例
- 首先，用例提供了一种基于构建故事的半形式化框架，参与者和用例，以及它们间的通信规则，不足以讲述一个故事，故事必须有一个目的。用Ivar Jscobson的话说，“为系统内的单个参与者产生一个有可度量价值的结果”
- 其次，在每个用例和所有描述层次中，用例都描述了错误情况的系统需求
- 再次，虽然用例本质上是一种功能分解技术，但它们已经成为面向对象软件开发的一个流行元素
- 最后，用例提供了可以在其上处理其他项目信息的骨架：
    - 项目经理可以根据用例进行估计和发布进度；
    - 数据及业务规则制定人员可以把自己的需求和所需用例联系起来；
    - 界面设计人员可以进行设计，并将其与相关用例联系起来；
    - 测试人员可以根据用例中描述的成功和失败情况构建测试场景。

## 讲述好故事的困难
- 用户界面细节太多，通常发现对鼠标点击、列表框和窗口设计的引用，用户界面设计细节通常不是需求，它们一般是设计选择，在编写并评审了用例之后，才需要做出设计选择，`Adornments`模式和`TechnologyNeutral`模式阐述如何避免过多的细节
- 较低目标层次上的用例太多，程序员经常会在“验证用户身份”这类层次上生成大量低层次用例，很大程度是因为这些功能必须实现，但这样编写的需求文档就很长，难以阅读，也无法展示系统给最终用户和客户提供什么功能。`CompleteSingleGoal`模式讲述了如何适当地构建用例，避免这类问题
- 使用用例表示非行为信息。其实用例只适用于描述行为，有些人员用非常详细的用例描述用户界面表单的完成。最好是创建一个`Adornment`，将性能需求、复杂的业务规则、数据结构等放入
- 太冗长，较好的用例通常为3~9步，`LeveledSteps`模式讲述如何编写均衡、大小适度的用例
- 目标实现不完整，编写人员没有捕获目标实现的全部行为，而只是描述了所必需行为的一个片断。由于用例间没有联系，程序员只能猜测如何将它们连在一起，没有考虑所有故障情况或可选行为。`CompleteSingleGoal`模式和`ExhaustiveAlternatives`模式就如何把目标和用例联系起来，以及如何包括所有必须的失败情况给出了建议
- 句子片断，一个相对较小但也要注意的错误是不要用句子片断编写用例。如果在操作步骤中省略了参与者名称，就很容易导致项目过程混乱。`ActorIntentAccomplished`模式讲述了如何编写步骤清晰且无二义性的场景

## 用例模式表格
- __模式名称__
    + 强调所建议解决方案的共性的名词短语。
    + 如`UserValuedTransactions`这个名称让人觉得该服务是对某个人是有价值的
- __一张图片__
    + 为模式提供一个形象的比喻。
    + 如`UserValuedTransactions`的形象比喻是排队准备为赛马下注的人，他们愿意排队付款，说明他们认为这一行动是值得的
- __上下文__
    + 问题发生的条件，描述了限制模式和解决方案适用场合的边界，还描述了该模式如何与语言中其他模式相关，并指出了哪些模式是该模式的先决条件。
    + 如`UserValuedTransactions`的上下文是：已经建立了项目的`SharedClearVision`，并定义了需要系统提供服务的`ClearCastOfCharacters`
- __问题陈述__
    + 由一两个句子组成，这些句子描述了当用例不能满足一定的标准时会发生什么情况，这些陈述还反映了 __不遵照该标准带来的风险__。
    + 如`UserValuedTransactions`的问题陈述为：如果系统不能对用户提供有价值的服务，并且不支持系统愿意规定的目的和目标，那么，该系统就是不完善的
- __隐喻故事__
    + 提供隐喻故事，以使模式更易于理解
- __影响问题的约束__
    + 概述了影响问题的各种因素，以及在使解决方案复杂化和约束解决方案的各种因素之间的权衡，这部分描述了编写者必须对所面对的具体情况作出重要权衡
    + 如`UserValuedTransactions`，我们需要平衡的约束：
        * 一组用例应该捕获用户和涉众需要系统提供的基本增值服务
        * 识别低层事务相对较为容易，但识别有用的服务可能就难了
        * 用例需要相对稳定，因为它们形成了产品开发过程其他部分的“定位点”
        * 读者希望容易看到系统如何满足其目标（请看`SharedClearVision`）
        * 人们有一种太高或太低的层次上工作的倾向
- __解决方案__
    + 该解决方案是平衡了相互竞争的约束，并反映了编写良好的用例的特征
    + 如`UserValuedTransactions`的基本解决方案是：识别系统为参与者提供以满足其业务目的的有价值服务
- __示例__
    + 每个模式都有一个或多个示例，证明实现模式所建议的解决方案的好处，或不这样做的后果

## 模式语言的组织
31个模式分两大类：开发模式和结构模式

### 开发模式
描述了已经过验证的用例编写实践的特征，并提供了度量编写过程质量的准测

- __团队组织__：判断和改进用例团队组织方式的质量的模式
    + 团队的人员的变化是一个重要但经常被忽视的方面。在对所得到用例的影响方面，编写人员之间的个人交互与用于识别编写用例的技术造成的影响不相上下
    + 编写`PreciseAndReadable`用例要求有一个`BalancedTeam`和一个`ParticipatingAudience`。赞助者、开发人员、交互专家和领域专家都参与这项工作并对它进行评审。然而编写人员太多反而会把问题搞砸，任何一个编写任务都应该使用一个`SmallWritingTeam`
- __过程__：判断和改进团队用来创建用例的方法质量的模式
    + 遵循一个好的过程对于编写高质量的用例非常关键，该过程不一定很讲究或很强大，但一定要包括所有基本成分。好的过程意味着平衡发现和编写，用足够内容对系统进行充分描述，不返工，不做多余工作，以使开发人员能够开始构建系统
    + 尽管不提倡创建用例的任何具体过程，但高效的团队都使用`BreadthBeforeDepth`，部分扩展一些用例之前，首先命名许多用例，在考虑失败处理之前完成主成功场景，并实现用例集的`SpiralDevelopment`
    + `SmallWritingTeam`将它的工作与`TwoTierReview`集成在一起，其中，具有不同专长的核心工作人员先对工作进行评审和调整，然后才将其交给包括有涉众代表的团队
    + 有效的团队知道什么时候是`QuittingTime`，团队成员不会长时间争论一个肤浅的问题，而是允许一定数量的`WritersLicense`，他们认识到强迫所有人员使用一致的编写习惯或不太得要的标准很快就会使这项工作不再增加价值
    + 并不是每个项目团队都需要相同数量的细节来完成其任务，用例的`MultipleForms`是需要的，也可将每个格式用到同一个项目的不同时段上
- __编辑__：随着潜在需求的变化和编写人员知识的增加，判断和改进单个用例质量的模式
    + 因为潜在的需求非常不稳定且容易发生变化，因此，用例可能很快就会过时，随着对系统深入理解，它会发生变化，通过调查与客户交谈，可以加深对系统的了解。
    + 在编写过程中，组员会定期发现他们编写的用例要么大而复杂、难以阅读，要么小、不重要。应该将大的用例`RedistributeTheWealth`分成较小的用例，并太小的用例`MergeDroplets`合并到其他用例中。最终，他们可能会发现一些用例完全无关的，为了处理这些用例，可以`CleanHouse`

### 结构模式
描述了用例的基本组成部分，解释了应该如何对其进行组织，并提供了判断其使用的准测

- __用例集__：判断和改进用例集质量的模式
    + 用例集是用例和相关信息的集合，它以一种便于使用的方式组织为用例模型，包括产品的系统级信息，包括参与者、边界以及成员用例之间的关系，这一级别主要是组织级的，描述是集合的关键特性而非具体行为。在这一级别工作的人们通常根据名字引用单个用例，忽视它们的内容
    + 用例集最重要事情是，应该清晰的`VisibleBoundary`来反映系统的`SharedClearVision`。用例共同组织为较高层的用例，这些高层用例从`EverUnfoldingStory`中引用低层用例，`EverUnfoldingStory`则展示了`ClearCastOfCharacters`，它们与系统交互来实现它们的目标。尽管在各个级别上都有描述的目标，但最关键和有兴趣的目标描述的是`UserValuedTransactions`。
- __用例__：判断和改进单个用例质量的模式
    + 单个用例描述对`CompleteSingleGoal`的追求，它应该有一个描述性的`VerbPhraseName`来让读者了解它的意图，每个用例都对可以实现它的多种方式，成功的、不成功的，用一个描述在不同条件下将会发生什么情况的场景片断集合，组织成`ScenarioPlusFragments`，一个完整的用例考虑`ExhaustiveAlternatives`
    + 为了使赞助者、用户和开发人员满意，编写人员要力争使用例`PreciseAndReadable`，这是用例编写的一种技巧，同时也是一种可实现的目标，从用例文本中消除性能需求、数据格式以及用户界面，用文档分离它们，作为`Adornments`
- __场景和步骤__：判断和改进用例场景以及这些场景中的步骤质量的模式
    + 场景描述了用例中一个完整的事件序列。主成功场景后的每个场景片断都描述了参与者在某些`DetectableConditions`下的行为（对讨论中的系统来说是可检测的）。良好用例的可读性部分是`LeveledSteps`，它使所有的步骤都保持在大致相同的详细级别上
    + 每个步骤都应该使不同的`ForwardProgress`靠近目标。由于用户界面细节和其他设计决策作为`Adornments`出现的，因此能够用`TechnologyNeutral`方式详尽编写每一个步骤，最后，每一个步骤都应该使`ActorIntentAccomplished`，读者总能说出谁在做什么
- __用例关系__：判断和改进集合中用例之间的结构关系质量的模式
    + Ivar Jscobson定义了 __“包含”、“泛化”、“扩展”__ 的概念
    + 当一组共有的动作在几个用例中再次出现时，最简单和最自然的联系就是把`CommonSubBehavior`移到由其他用例通过“包含”关系引用的子用例中。
    + 当单个事件可能多次中断用例流时，编写人员就应该把那些中断编成扩展（`InterruptsAsExtensions`）
    + 如果一个给定的分支开始支配用例，那么，应该考虑把分支提升为扩展用例，即`PromotedAlternative`
    + `CapuredAbstraction`建议何时使用泛化


团队
======
